---
title: Azure Storage-prestanda och skalbarhet Checklista | Microsoft Docs
description: "En checklista beprövade metoder för användning med Azure Storage i utvecklar performant program."
services: storage
documentationcenter: 
author: robinsh
manager: timlt
editor: tysonn
ms.assetid: 959d831b-a4fd-4634-a646-0d2c0c462ef8
ms.service: storage
ms.workload: storage
ms.tgt_pltfrm: na
ms.devlang: na
ms.topic: article
ms.date: 12/08/2016
ms.author: robinsh
ms.openlocfilehash: d2683bf9a2833485467bf2b4edff527876102f7d
ms.sourcegitcommit: 18ad9bc049589c8e44ed277f8f43dcaa483f3339
ms.translationtype: MT
ms.contentlocale: sv-SE
ms.lasthandoff: 08/29/2017
---
# <a name="microsoft-azure-storage-performance-and-scalability-checklist"></a><span data-ttu-id="dcc54-103">Prestanda och skalbarhetschecklista för Microsoft Azure Storage</span><span class="sxs-lookup"><span data-stu-id="dcc54-103">Microsoft Azure Storage Performance and Scalability Checklist</span></span>
## <a name="overview"></a><span data-ttu-id="dcc54-104">Översikt</span><span class="sxs-lookup"><span data-stu-id="dcc54-104">Overview</span></span>
<span data-ttu-id="dcc54-105">Microsoft har utvecklat ett antal beprövade metoder för att använda dessa tjänster på ett sätt som performant efter utgivningen av Microsoft Azure Storage-tjänster, och den här artikeln används för konsolidera viktigaste av dem till en lista med checklista-format.</span><span class="sxs-lookup"><span data-stu-id="dcc54-105">Since the release of the Microsoft Azure Storage services, Microsoft has developed a number of proven practices for using these services in a performant manner, and this article serves to consolidate the most important of them into a checklist-style list.</span></span> <span data-ttu-id="dcc54-106">Syftet med den här artikeln är att kontrollera de använder beprövade metoder med Azure Storage programutvecklare och hjälper dem att identifiera andra beprövade metoder som de bör införandet.</span><span class="sxs-lookup"><span data-stu-id="dcc54-106">The intention of this article is to help application developers verify they are using proven practices with Azure Storage and to help them identify other proven practices they should consider adopting.</span></span> <span data-ttu-id="dcc54-107">Den här artikeln försöker inte att täcka alla möjliga optimering av prestanda och skalbarhet – den utesluter som är litet i deras inverkan eller brett ej tillämpligt.</span><span class="sxs-lookup"><span data-stu-id="dcc54-107">This article does not attempt to cover every possible performance and scalability optimization — it excludes those that are small in their impact or not broadly applicable.</span></span> <span data-ttu-id="dcc54-108">Att programmets beteende kan förutsägas under design, är det bra att behålla dem i åtanke för tidigt för att undvika design som ska köras i prestandaproblem.</span><span class="sxs-lookup"><span data-stu-id="dcc54-108">To the extent that the application's behavior can be predicted during design, it's useful to keep these in mind early on to avoid designs that will run into performance problems.</span></span>  

<span data-ttu-id="dcc54-109">Varje programutvecklaren med hjälp av Azure Storage bör ta tid att läsa den här artikeln och kontrollera att hans eller hennes program följer varje beprövade metoder som anges nedan.</span><span class="sxs-lookup"><span data-stu-id="dcc54-109">Every application developer using Azure Storage should take the time to read this article, and check that his or her application follows each of the proven practices listed below.</span></span>  

## <a name="checklist"></a><span data-ttu-id="dcc54-110">Checklista</span><span class="sxs-lookup"><span data-stu-id="dcc54-110">Checklist</span></span>
<span data-ttu-id="dcc54-111">Den här artikeln organiserar beprövade metoder i följande grupper.</span><span class="sxs-lookup"><span data-stu-id="dcc54-111">This article organizes the proven practices into the following groups.</span></span> <span data-ttu-id="dcc54-112">Beprövade metoder som gäller för:</span><span class="sxs-lookup"><span data-stu-id="dcc54-112">Proven practices applicable to:</span></span>  

* <span data-ttu-id="dcc54-113">Alla Azure Storage-tjänster (blobbar, tabeller, köer och filer)</span><span class="sxs-lookup"><span data-stu-id="dcc54-113">All Azure Storage services (blobs, tables, queues, and files)</span></span>
* <span data-ttu-id="dcc54-114">Blobar</span><span class="sxs-lookup"><span data-stu-id="dcc54-114">Blobs</span></span>
* <span data-ttu-id="dcc54-115">Tabeller</span><span class="sxs-lookup"><span data-stu-id="dcc54-115">Tables</span></span>
* <span data-ttu-id="dcc54-116">Köer</span><span class="sxs-lookup"><span data-stu-id="dcc54-116">Queues</span></span>  

| <span data-ttu-id="dcc54-117">Klart</span><span class="sxs-lookup"><span data-stu-id="dcc54-117">Done</span></span> | <span data-ttu-id="dcc54-118">Område</span><span class="sxs-lookup"><span data-stu-id="dcc54-118">Area</span></span> | <span data-ttu-id="dcc54-119">Kategori</span><span class="sxs-lookup"><span data-stu-id="dcc54-119">Category</span></span> | <span data-ttu-id="dcc54-120">Fråga</span><span class="sxs-lookup"><span data-stu-id="dcc54-120">Question</span></span> |
| --- | --- | --- | --- |
| &nbsp; | <span data-ttu-id="dcc54-121">Alla tjänster</span><span class="sxs-lookup"><span data-stu-id="dcc54-121">All Services</span></span> |<span data-ttu-id="dcc54-122">Skalbarhetsmål</span><span class="sxs-lookup"><span data-stu-id="dcc54-122">Scalability Targets</span></span> |[<span data-ttu-id="dcc54-123">Är programmet som utformats för att undvika närmar sig skalbarhetsmål?</span><span class="sxs-lookup"><span data-stu-id="dcc54-123">Is your application designed to avoid approaching the scalability targets?</span></span>](#subheading1) |
| &nbsp; | <span data-ttu-id="dcc54-124">Alla tjänster</span><span class="sxs-lookup"><span data-stu-id="dcc54-124">All Services</span></span> |<span data-ttu-id="dcc54-125">Skalbarhetsmål</span><span class="sxs-lookup"><span data-stu-id="dcc54-125">Scalability Targets</span></span> |[<span data-ttu-id="dcc54-126">Din namngivningskonvention utformats för att bättre belastningsutjämning?</span><span class="sxs-lookup"><span data-stu-id="dcc54-126">Is your naming convention designed to enable better load-balancing?</span></span>](#subheading47) |
| &nbsp; | <span data-ttu-id="dcc54-127">Alla tjänster</span><span class="sxs-lookup"><span data-stu-id="dcc54-127">All Services</span></span> |<span data-ttu-id="dcc54-128">Nätverk</span><span class="sxs-lookup"><span data-stu-id="dcc54-128">Networking</span></span> |[<span data-ttu-id="dcc54-129">Har sida klientenheter tillräckligt hög bandbredd och låg latens för att uppnå de prestanda som behövs?</span><span class="sxs-lookup"><span data-stu-id="dcc54-129">Do client side devices have sufficiently high bandwidth and low latency to achieve the performance needed?</span></span>](#subheading2) |
| &nbsp; | <span data-ttu-id="dcc54-130">Alla tjänster</span><span class="sxs-lookup"><span data-stu-id="dcc54-130">All Services</span></span> |<span data-ttu-id="dcc54-131">Nätverk</span><span class="sxs-lookup"><span data-stu-id="dcc54-131">Networking</span></span> |[<span data-ttu-id="dcc54-132">Har sida klientenheter en tillräckligt hög kvalitet länk?</span><span class="sxs-lookup"><span data-stu-id="dcc54-132">Do client side devices have a high enough quality link?</span></span>](#subheading3) |
| &nbsp; | <span data-ttu-id="dcc54-133">Alla tjänster</span><span class="sxs-lookup"><span data-stu-id="dcc54-133">All Services</span></span> |<span data-ttu-id="dcc54-134">Nätverk</span><span class="sxs-lookup"><span data-stu-id="dcc54-134">Networking</span></span> |[<span data-ttu-id="dcc54-135">Klientprogrammet finns ”” storage-konto?</span><span class="sxs-lookup"><span data-stu-id="dcc54-135">Is the client application located "near" the storage account?</span></span>](#subheading4) |
| &nbsp; | <span data-ttu-id="dcc54-136">Alla tjänster</span><span class="sxs-lookup"><span data-stu-id="dcc54-136">All Services</span></span> |<span data-ttu-id="dcc54-137">Innehållsdistribution</span><span class="sxs-lookup"><span data-stu-id="dcc54-137">Content Distribution</span></span> |[<span data-ttu-id="dcc54-138">Använder du en CDN för innehållsdistribution?</span><span class="sxs-lookup"><span data-stu-id="dcc54-138">Are you using a CDN for content distribution?</span></span>](#subheading5) |
| &nbsp; | <span data-ttu-id="dcc54-139">Alla tjänster</span><span class="sxs-lookup"><span data-stu-id="dcc54-139">All Services</span></span> |<span data-ttu-id="dcc54-140">En klient direkt åtkomst</span><span class="sxs-lookup"><span data-stu-id="dcc54-140">Direct Client Access</span></span> |[<span data-ttu-id="dcc54-141">Du använder SAS och CORS för direkt åtkomst till lagring i stället för proxy?</span><span class="sxs-lookup"><span data-stu-id="dcc54-141">Are you using SAS and CORS to allow direct access to storage instead of proxy?</span></span>](#subheading6) |
| &nbsp; | <span data-ttu-id="dcc54-142">Alla tjänster</span><span class="sxs-lookup"><span data-stu-id="dcc54-142">All Services</span></span> |<span data-ttu-id="dcc54-143">Cachelagring</span><span class="sxs-lookup"><span data-stu-id="dcc54-143">Caching</span></span> |[<span data-ttu-id="dcc54-144">Är programmet cachelagring data används flera gånger och ändringar sällan?</span><span class="sxs-lookup"><span data-stu-id="dcc54-144">Is your application caching data that is repeatedly used and changes rarely?</span></span>](#subheading7) |
| &nbsp; | <span data-ttu-id="dcc54-145">Alla tjänster</span><span class="sxs-lookup"><span data-stu-id="dcc54-145">All Services</span></span> |<span data-ttu-id="dcc54-146">Cachelagring</span><span class="sxs-lookup"><span data-stu-id="dcc54-146">Caching</span></span> |[<span data-ttu-id="dcc54-147">Tillämpningsprogrammet är grupperade uppdateringar (cachelagring på klientsidan för dem och sedan ladda upp i större mängder)?</span><span class="sxs-lookup"><span data-stu-id="dcc54-147">Is your application batching updates (caching them client side and then uploading in larger sets)?</span></span>](#subheading8) |
| &nbsp; | <span data-ttu-id="dcc54-148">Alla tjänster</span><span class="sxs-lookup"><span data-stu-id="dcc54-148">All Services</span></span> |<span data-ttu-id="dcc54-149">.NET-konfiguration</span><span class="sxs-lookup"><span data-stu-id="dcc54-149">.NET Configuration</span></span> |[<span data-ttu-id="dcc54-150">Har du konfigurerat din klient om du vill använda ett tillräckligt antal samtidiga anslutningar?</span><span class="sxs-lookup"><span data-stu-id="dcc54-150">Have you configured your client to use a sufficient number of concurrent connections?</span></span>](#subheading9) |
| &nbsp; | <span data-ttu-id="dcc54-151">Alla tjänster</span><span class="sxs-lookup"><span data-stu-id="dcc54-151">All Services</span></span> |<span data-ttu-id="dcc54-152">.NET-konfiguration</span><span class="sxs-lookup"><span data-stu-id="dcc54-152">.NET Configuration</span></span> |[<span data-ttu-id="dcc54-153">Har du konfigurerat .NET för att använda ett tillräckligt antal trådar?</span><span class="sxs-lookup"><span data-stu-id="dcc54-153">Have you configured .NET to use a sufficient number of threads?</span></span>](#subheading10) |
| &nbsp; | <span data-ttu-id="dcc54-154">Alla tjänster</span><span class="sxs-lookup"><span data-stu-id="dcc54-154">All Services</span></span> |<span data-ttu-id="dcc54-155">.NET-konfiguration</span><span class="sxs-lookup"><span data-stu-id="dcc54-155">.NET Configuration</span></span> |[<span data-ttu-id="dcc54-156">Du använder .NET 4.5 eller senare som har förbättrats skräpinsamling?</span><span class="sxs-lookup"><span data-stu-id="dcc54-156">Are you using .NET 4.5 or later, which has improved garbage collection?</span></span>](#subheading11) |
| &nbsp; | <span data-ttu-id="dcc54-157">Alla tjänster</span><span class="sxs-lookup"><span data-stu-id="dcc54-157">All Services</span></span> |<span data-ttu-id="dcc54-158">Parallellitet</span><span class="sxs-lookup"><span data-stu-id="dcc54-158">Parallelism</span></span> |[<span data-ttu-id="dcc54-159">Har du sett till att parallellitet begränsas på lämpligt sätt så att du inte överlagra klientens kapacitet eller skalbarhetsmål?</span><span class="sxs-lookup"><span data-stu-id="dcc54-159">Have you ensured that parallelism is bounded appropriately so that you don't overload either your client capabilities or the scalability targets?</span></span>](#subheading12) |
| &nbsp; | <span data-ttu-id="dcc54-160">Alla tjänster</span><span class="sxs-lookup"><span data-stu-id="dcc54-160">All Services</span></span> |<span data-ttu-id="dcc54-161">Verktyg</span><span class="sxs-lookup"><span data-stu-id="dcc54-161">Tools</span></span> |[<span data-ttu-id="dcc54-162">Är du med hjälp av den senaste versionen av Microsoft tillhandahålls klientbibliotek och verktyg?</span><span class="sxs-lookup"><span data-stu-id="dcc54-162">Are you using the latest version of Microsoft provided client libraries and tools?</span></span>](#subheading13) |
| &nbsp; | <span data-ttu-id="dcc54-163">Alla tjänster</span><span class="sxs-lookup"><span data-stu-id="dcc54-163">All Services</span></span> |<span data-ttu-id="dcc54-164">Antal försök</span><span class="sxs-lookup"><span data-stu-id="dcc54-164">Retries</span></span> |[<span data-ttu-id="dcc54-165">Är du med hjälp av en exponentiell backoff försök principer för begränsning av fel och tidsgränser?</span><span class="sxs-lookup"><span data-stu-id="dcc54-165">Are you using an exponential backoff retry policy for throttling errors and timeouts?</span></span>](#subheading14) |
| &nbsp; | <span data-ttu-id="dcc54-166">Alla tjänster</span><span class="sxs-lookup"><span data-stu-id="dcc54-166">All Services</span></span> |<span data-ttu-id="dcc54-167">Antal försök</span><span class="sxs-lookup"><span data-stu-id="dcc54-167">Retries</span></span> |[<span data-ttu-id="dcc54-168">Är programmet Undvik nya försök för icke-återförsökbart fel?</span><span class="sxs-lookup"><span data-stu-id="dcc54-168">Is your application avoiding retries for non-retryable errors?</span></span>](#subheading15) |
| &nbsp; | <span data-ttu-id="dcc54-169">Blobar</span><span class="sxs-lookup"><span data-stu-id="dcc54-169">Blobs</span></span> |<span data-ttu-id="dcc54-170">Skalbarhetsmål</span><span class="sxs-lookup"><span data-stu-id="dcc54-170">Scalability Targets</span></span> |[<span data-ttu-id="dcc54-171">Har du ett stort antal klienter som ansluter till ett enda objekt samtidigt?</span><span class="sxs-lookup"><span data-stu-id="dcc54-171">Do you have a large number of clients accessing a single object concurrently?</span></span>](#subheading46) |
| &nbsp; | <span data-ttu-id="dcc54-172">Blobar</span><span class="sxs-lookup"><span data-stu-id="dcc54-172">Blobs</span></span> |<span data-ttu-id="dcc54-173">Skalbarhetsmål</span><span class="sxs-lookup"><span data-stu-id="dcc54-173">Scalability Targets</span></span> |[<span data-ttu-id="dcc54-174">Är programmet dig inom bandbredd eller åtgärder skalbarhet mål för en enda blob?</span><span class="sxs-lookup"><span data-stu-id="dcc54-174">Is your application staying within the bandwidth or operations scalability target for a single blob?</span></span>](#subheading16) |
| &nbsp; | <span data-ttu-id="dcc54-175">Blobar</span><span class="sxs-lookup"><span data-stu-id="dcc54-175">Blobs</span></span> |<span data-ttu-id="dcc54-176">Kopiera BLOB</span><span class="sxs-lookup"><span data-stu-id="dcc54-176">Copying Blobs</span></span> |[<span data-ttu-id="dcc54-177">Vill du kopiera BLOB på ett effektivt sätt?</span><span class="sxs-lookup"><span data-stu-id="dcc54-177">Are you copying blobs in an efficient manner?</span></span>](#subheading17) |
| &nbsp; | <span data-ttu-id="dcc54-178">Blobar</span><span class="sxs-lookup"><span data-stu-id="dcc54-178">Blobs</span></span> |<span data-ttu-id="dcc54-179">Kopiera BLOB</span><span class="sxs-lookup"><span data-stu-id="dcc54-179">Copying Blobs</span></span> |[<span data-ttu-id="dcc54-180">Använder du AzCopy för bulk kopior av blobbar?</span><span class="sxs-lookup"><span data-stu-id="dcc54-180">Are you using AzCopy for bulk copies of blobs?</span></span>](#subheading18) |
| &nbsp; | <span data-ttu-id="dcc54-181">Blobar</span><span class="sxs-lookup"><span data-stu-id="dcc54-181">Blobs</span></span> |<span data-ttu-id="dcc54-182">Kopiera BLOB</span><span class="sxs-lookup"><span data-stu-id="dcc54-182">Copying Blobs</span></span> |[<span data-ttu-id="dcc54-183">Använder du Azure Import/Export för att överföra stora mängder data?</span><span class="sxs-lookup"><span data-stu-id="dcc54-183">Are you using Azure Import/Export to transfer very large volumes of data?</span></span>](#subheading19) |
| &nbsp; | <span data-ttu-id="dcc54-184">Blobar</span><span class="sxs-lookup"><span data-stu-id="dcc54-184">Blobs</span></span> |<span data-ttu-id="dcc54-185">Använda Metadata</span><span class="sxs-lookup"><span data-stu-id="dcc54-185">Use Metadata</span></span> |[<span data-ttu-id="dcc54-186">Lagrar du vanliga metadata om blobbar i sina metadata?</span><span class="sxs-lookup"><span data-stu-id="dcc54-186">Are you storing frequently used metadata about blobs in their metadata?</span></span>](#subheading20) |
| &nbsp; | <span data-ttu-id="dcc54-187">Blobar</span><span class="sxs-lookup"><span data-stu-id="dcc54-187">Blobs</span></span> |<span data-ttu-id="dcc54-188">Snabb överföring</span><span class="sxs-lookup"><span data-stu-id="dcc54-188">Uploading Fast</span></span> |[<span data-ttu-id="dcc54-189">När du försöker överföra en blob snabbt du överför block parallellt?</span><span class="sxs-lookup"><span data-stu-id="dcc54-189">When trying to upload one blob quickly, are you uploading blocks in parallel?</span></span>](#subheading21) |
| &nbsp; | <span data-ttu-id="dcc54-190">Blobar</span><span class="sxs-lookup"><span data-stu-id="dcc54-190">Blobs</span></span> |<span data-ttu-id="dcc54-191">Snabb överföring</span><span class="sxs-lookup"><span data-stu-id="dcc54-191">Uploading Fast</span></span> |[<span data-ttu-id="dcc54-192">När du försöker överföra många blobbar snabbt du överför blobbar parallellt?</span><span class="sxs-lookup"><span data-stu-id="dcc54-192">When trying to upload many blobs quickly, are you uploading blobs in parallel?</span></span>](#subheading22) |
| &nbsp; | <span data-ttu-id="dcc54-193">Blobar</span><span class="sxs-lookup"><span data-stu-id="dcc54-193">Blobs</span></span> |<span data-ttu-id="dcc54-194">Korrigera Blobbtypen</span><span class="sxs-lookup"><span data-stu-id="dcc54-194">Correct Blob Type</span></span> |[<span data-ttu-id="dcc54-195">Du använder sidblobbar eller blockblobbar när det är lämpligt?</span><span class="sxs-lookup"><span data-stu-id="dcc54-195">Are you using page blobs or block blobs when appropriate?</span></span>](#subheading23) |
| &nbsp; | <span data-ttu-id="dcc54-196">Tabeller</span><span class="sxs-lookup"><span data-stu-id="dcc54-196">Tables</span></span> |<span data-ttu-id="dcc54-197">Skalbarhetsmål</span><span class="sxs-lookup"><span data-stu-id="dcc54-197">Scalability Targets</span></span> |[<span data-ttu-id="dcc54-198">Du närmar dig skalbarhetsmål för entiteter per sekund?</span><span class="sxs-lookup"><span data-stu-id="dcc54-198">Are you approaching the scalability targets for entities per second?</span></span>](#subheading24) |
| &nbsp; | <span data-ttu-id="dcc54-199">Tabeller</span><span class="sxs-lookup"><span data-stu-id="dcc54-199">Tables</span></span> |<span data-ttu-id="dcc54-200">Konfiguration</span><span class="sxs-lookup"><span data-stu-id="dcc54-200">Configuration</span></span> |[<span data-ttu-id="dcc54-201">Använder du JSON för tabell-begäranden?</span><span class="sxs-lookup"><span data-stu-id="dcc54-201">Are you using JSON for your table requests?</span></span>](#subheading25) |
| &nbsp; | <span data-ttu-id="dcc54-202">Tabeller</span><span class="sxs-lookup"><span data-stu-id="dcc54-202">Tables</span></span> |<span data-ttu-id="dcc54-203">Konfiguration</span><span class="sxs-lookup"><span data-stu-id="dcc54-203">Configuration</span></span> |[<span data-ttu-id="dcc54-204">Har du inaktiverat Nagle kan förbättra prestanda för små begäran?</span><span class="sxs-lookup"><span data-stu-id="dcc54-204">Have you turned Nagle off to improve the performance of small requests?</span></span>](#subheading26) |
| &nbsp; | <span data-ttu-id="dcc54-205">Tabeller</span><span class="sxs-lookup"><span data-stu-id="dcc54-205">Tables</span></span> |<span data-ttu-id="dcc54-206">Tabeller och partitioner</span><span class="sxs-lookup"><span data-stu-id="dcc54-206">Tables and Partitions</span></span> |[<span data-ttu-id="dcc54-207">Har du rätt partitionerat data?</span><span class="sxs-lookup"><span data-stu-id="dcc54-207">Have you properly partitioned your data?</span></span>](#subheading27) |
| &nbsp; | <span data-ttu-id="dcc54-208">Tabeller</span><span class="sxs-lookup"><span data-stu-id="dcc54-208">Tables</span></span> |<span data-ttu-id="dcc54-209">Varm partitioner</span><span class="sxs-lookup"><span data-stu-id="dcc54-209">Hot Partitions</span></span> |[<span data-ttu-id="dcc54-210">Är du undvika Lägg endast och endast lägga mönster?</span><span class="sxs-lookup"><span data-stu-id="dcc54-210">Are you avoiding append-only and prepend-only patterns?</span></span>](#subheading28) |
| &nbsp; | <span data-ttu-id="dcc54-211">Tabeller</span><span class="sxs-lookup"><span data-stu-id="dcc54-211">Tables</span></span> |<span data-ttu-id="dcc54-212">Varm partitioner</span><span class="sxs-lookup"><span data-stu-id="dcc54-212">Hot Partitions</span></span> |[<span data-ttu-id="dcc54-213">Infogningar/uppdateringar är fördelade på flera partitioner?</span><span class="sxs-lookup"><span data-stu-id="dcc54-213">Are your inserts/updates spread across many partitions?</span></span>](#subheading29) |
| &nbsp; | <span data-ttu-id="dcc54-214">Tabeller</span><span class="sxs-lookup"><span data-stu-id="dcc54-214">Tables</span></span> |<span data-ttu-id="dcc54-215">Frågeomfattningen</span><span class="sxs-lookup"><span data-stu-id="dcc54-215">Query Scope</span></span> |[<span data-ttu-id="dcc54-216">Har du skapat schemat för punkt frågor som ska användas i de flesta fall och tabellen frågor som ska användas sparsamt?</span><span class="sxs-lookup"><span data-stu-id="dcc54-216">Have you designed your schema to allow for point queries to be used in most cases, and table queries to be used sparingly?</span></span>](#subheading30) |
| &nbsp; | <span data-ttu-id="dcc54-217">Tabeller</span><span class="sxs-lookup"><span data-stu-id="dcc54-217">Tables</span></span> |<span data-ttu-id="dcc54-218">Frågan densitet</span><span class="sxs-lookup"><span data-stu-id="dcc54-218">Query Density</span></span> |[<span data-ttu-id="dcc54-219">Gör dina frågor vanligtvis endast genomsökning och returnerar rader som ska använda för ditt program?</span><span class="sxs-lookup"><span data-stu-id="dcc54-219">Do your queries typically only scan and return rows that your application will use?</span></span>](#subheading31) |
| &nbsp; | <span data-ttu-id="dcc54-220">Tabeller</span><span class="sxs-lookup"><span data-stu-id="dcc54-220">Tables</span></span> |<span data-ttu-id="dcc54-221">Begränsa returnerade Data</span><span class="sxs-lookup"><span data-stu-id="dcc54-221">Limiting Returned Data</span></span> |[<span data-ttu-id="dcc54-222">Du använder filtrering för att undvika att enheter som inte behövs?</span><span class="sxs-lookup"><span data-stu-id="dcc54-222">Are you using filtering to avoid returning entities that are not needed?</span></span>](#subheading32) |
| &nbsp; | <span data-ttu-id="dcc54-223">Tabeller</span><span class="sxs-lookup"><span data-stu-id="dcc54-223">Tables</span></span> |<span data-ttu-id="dcc54-224">Begränsa returnerade Data</span><span class="sxs-lookup"><span data-stu-id="dcc54-224">Limiting Returned Data</span></span> |[<span data-ttu-id="dcc54-225">Använder du projektion för att undvika att egenskaper som inte behövs?</span><span class="sxs-lookup"><span data-stu-id="dcc54-225">Are you using projection to avoid returning properties that are not needed?</span></span>](#subheading33) |
| &nbsp; | <span data-ttu-id="dcc54-226">Tabeller</span><span class="sxs-lookup"><span data-stu-id="dcc54-226">Tables</span></span> |<span data-ttu-id="dcc54-227">Denormalization</span><span class="sxs-lookup"><span data-stu-id="dcc54-227">Denormalization</span></span> |[<span data-ttu-id="dcc54-228">Har du Avnormaliserade dina data så att du undviker ineffektiva frågor eller flera läsbegäranden vid försök att hämta data?</span><span class="sxs-lookup"><span data-stu-id="dcc54-228">Have you denormalized your data such that you avoid inefficient queries or multiple read requests when trying to get data?</span></span>](#subheading34) |
| &nbsp; | <span data-ttu-id="dcc54-229">Tabeller</span><span class="sxs-lookup"><span data-stu-id="dcc54-229">Tables</span></span> |<span data-ttu-id="dcc54-230">Insert/Update/Delete</span><span class="sxs-lookup"><span data-stu-id="dcc54-230">Insert/Update/Delete</span></span> |[<span data-ttu-id="dcc54-231">Är du batchbearbetning begäranden som måste vara en transaktionskö eller kan göras samtidigt minska turer?</span><span class="sxs-lookup"><span data-stu-id="dcc54-231">Are you batching requests that need to be transactional or can be done at the same time to reduce round-trips?</span></span>](#subheading35) |
| &nbsp; | <span data-ttu-id="dcc54-232">Tabeller</span><span class="sxs-lookup"><span data-stu-id="dcc54-232">Tables</span></span> |<span data-ttu-id="dcc54-233">Insert/Update/Delete</span><span class="sxs-lookup"><span data-stu-id="dcc54-233">Insert/Update/Delete</span></span> |[<span data-ttu-id="dcc54-234">Är du undvika att hämta en entitet bara för att avgöra om att anropa insert eller update?</span><span class="sxs-lookup"><span data-stu-id="dcc54-234">Are you avoiding retrieving an entity just to determine whether to call insert or update?</span></span>](#subheading36) |
| &nbsp; | <span data-ttu-id="dcc54-235">Tabeller</span><span class="sxs-lookup"><span data-stu-id="dcc54-235">Tables</span></span> |<span data-ttu-id="dcc54-236">Insert/Update/Delete</span><span class="sxs-lookup"><span data-stu-id="dcc54-236">Insert/Update/Delete</span></span> |[<span data-ttu-id="dcc54-237">Har du funderat lagra serien med data som hämtas ofta tillsammans i en enda enhet som egenskaper i stället för flera enheter?</span><span class="sxs-lookup"><span data-stu-id="dcc54-237">Have you considered storing series of data that will frequently be retrieved together in a single entity as properties instead of multiple entities?</span></span>](#subheading37) |
| &nbsp; | <span data-ttu-id="dcc54-238">Tabeller</span><span class="sxs-lookup"><span data-stu-id="dcc54-238">Tables</span></span> |<span data-ttu-id="dcc54-239">Insert/Update/Delete</span><span class="sxs-lookup"><span data-stu-id="dcc54-239">Insert/Update/Delete</span></span> |[<span data-ttu-id="dcc54-240">För enheter som hämtas alltid tillsammans och kan skrivas i batchar (t.ex. serien tidsdata), har du funderat med blobbar i stället för tabeller?</span><span class="sxs-lookup"><span data-stu-id="dcc54-240">For entities that will always be retrieved together and can be written in batches (e.g. time series data), have you considered using blobs instead of tables?</span></span>](#subheading38) |
| &nbsp; | <span data-ttu-id="dcc54-241">Köer</span><span class="sxs-lookup"><span data-stu-id="dcc54-241">Queues</span></span> |<span data-ttu-id="dcc54-242">Skalbarhetsmål</span><span class="sxs-lookup"><span data-stu-id="dcc54-242">Scalability Targets</span></span> |[<span data-ttu-id="dcc54-243">Du närmar dig skalbarhetsmål för meddelanden per sekund?</span><span class="sxs-lookup"><span data-stu-id="dcc54-243">Are you approaching the scalability targets for messages per second?</span></span>](#subheading39) |
| &nbsp; | <span data-ttu-id="dcc54-244">Köer</span><span class="sxs-lookup"><span data-stu-id="dcc54-244">Queues</span></span> |<span data-ttu-id="dcc54-245">Konfiguration</span><span class="sxs-lookup"><span data-stu-id="dcc54-245">Configuration</span></span> |[<span data-ttu-id="dcc54-246">Har du inaktiverat Nagle kan förbättra prestanda för små begäran?</span><span class="sxs-lookup"><span data-stu-id="dcc54-246">Have you turned Nagle off to improve the performance of small requests?</span></span>](#subheading40) |
| &nbsp; | <span data-ttu-id="dcc54-247">Köer</span><span class="sxs-lookup"><span data-stu-id="dcc54-247">Queues</span></span> |<span data-ttu-id="dcc54-248">Meddelandestorlek</span><span class="sxs-lookup"><span data-stu-id="dcc54-248">Message Size</span></span> |[<span data-ttu-id="dcc54-249">Är meddelanden-CD för att förbättra prestanda i kön?</span><span class="sxs-lookup"><span data-stu-id="dcc54-249">Are your messages compact to improve the performance of the queue?</span></span>](#subheading41) |
| &nbsp; | <span data-ttu-id="dcc54-250">Köer</span><span class="sxs-lookup"><span data-stu-id="dcc54-250">Queues</span></span> |<span data-ttu-id="dcc54-251">Hämta bulk</span><span class="sxs-lookup"><span data-stu-id="dcc54-251">Bulk Retrieve</span></span> |[<span data-ttu-id="dcc54-252">Hämtar du flera meddelanden i en enda åtgärd ”hämta”?</span><span class="sxs-lookup"><span data-stu-id="dcc54-252">Are you retrieving multiple messages in a single "Get" operation?</span></span>](#subheading42) |
| &nbsp; | <span data-ttu-id="dcc54-253">Köer</span><span class="sxs-lookup"><span data-stu-id="dcc54-253">Queues</span></span> |<span data-ttu-id="dcc54-254">Avsökningsfrekvens</span><span class="sxs-lookup"><span data-stu-id="dcc54-254">Polling Frequency</span></span> |[<span data-ttu-id="dcc54-255">Är du avsökning så ofta för att minska upplevd svarstiden för ditt program?</span><span class="sxs-lookup"><span data-stu-id="dcc54-255">Are you polling frequently enough to reduce the perceived latency of your application?</span></span>](#subheading43) |
| &nbsp; | <span data-ttu-id="dcc54-256">Köer</span><span class="sxs-lookup"><span data-stu-id="dcc54-256">Queues</span></span> |<span data-ttu-id="dcc54-257">Uppdatera meddelande</span><span class="sxs-lookup"><span data-stu-id="dcc54-257">Update Message</span></span> |[<span data-ttu-id="dcc54-258">Använder du UpdateMessage för att lagra förlopp i behandlar meddelanden undvika att behöva Ombearbeta hela meddelandet om ett fel inträffar?</span><span class="sxs-lookup"><span data-stu-id="dcc54-258">Are you using UpdateMessage to store progress in processing messages, avoiding having to reprocess the entire message if an error occurs?</span></span>](#subheading44) |
| &nbsp; | <span data-ttu-id="dcc54-259">Köer</span><span class="sxs-lookup"><span data-stu-id="dcc54-259">Queues</span></span> |<span data-ttu-id="dcc54-260">Arkitektur</span><span class="sxs-lookup"><span data-stu-id="dcc54-260">Architecture</span></span> |[<span data-ttu-id="dcc54-261">Använder du köer för att göra hela programmet mer skalbar genom att hålla tidskrävande arbetsbelastningar utanför den kritiska linjen och skala sedan oberoende av varandra?</span><span class="sxs-lookup"><span data-stu-id="dcc54-261">Are you using queues to make your entire application more scalable by keeping long-running workloads out of the critical path and scale then independently?</span></span>](#subheading45) |

## <span data-ttu-id="dcc54-262"><a name="allservices"></a>Alla tjänster</span><span class="sxs-lookup"><span data-stu-id="dcc54-262"><a name="allservices"></a>All Services</span></span>
<span data-ttu-id="dcc54-263">Det här avsnittet innehåller beprövade metoder som gäller för användning av någon av de Azure Storage-tjänsterna (blobbar, tabeller, köer eller filer).</span><span class="sxs-lookup"><span data-stu-id="dcc54-263">This section lists proven practices that are applicable to the use of any of the Azure Storage services (blobs, tables, queues, or files).</span></span>  

### <span data-ttu-id="dcc54-264"><a name="subheading1"></a>Skalbarhetsmål</span><span class="sxs-lookup"><span data-stu-id="dcc54-264"><a name="subheading1"></a>Scalability Targets</span></span>
<span data-ttu-id="dcc54-265">Varje Azure Storage-tjänster har skalbarhetsmål för kapacitet (GB), Transaktionshastighet och bandbredd.</span><span class="sxs-lookup"><span data-stu-id="dcc54-265">Each of the Azure Storage services has scalability targets for capacity (GB), transaction rate, and bandwidth.</span></span> <span data-ttu-id="dcc54-266">Om ditt program närmar sig eller överskrider något av skalbarhetsmål, stöta ökad transaktion fördröjningar eller begränsning.</span><span class="sxs-lookup"><span data-stu-id="dcc54-266">If your application approaches or exceeds any of the scalability targets, it may encounter increased transaction latencies or throttling.</span></span> <span data-ttu-id="dcc54-267">När en lagringstjänsten begränsar ditt program, börjar tjänsten att returnera ”503 servern upptagen” eller ”tidsgräns för 500 åtgärd” felkoder för vissa lagringstransaktioner.</span><span class="sxs-lookup"><span data-stu-id="dcc54-267">When a Storage service throttles your application, the service begins to return "503 Server busy" or "500 Operation timeout" error codes for some storage transactions.</span></span> <span data-ttu-id="dcc54-268">Det här avsnittet beskrivs både det allmänna tillvägagångssättet för hantera skalbarhetsmål och skalbarhetsmål för bandbredd särskilt.</span><span class="sxs-lookup"><span data-stu-id="dcc54-268">This section discusses both the general approach to dealing with scalability targets and bandwidth scalability targets in particular.</span></span> <span data-ttu-id="dcc54-269">Senare avsnitt som handlar om enskilda lagringstjänster beskrivs skalbarhetsmål i kontexten för den specifika tjänsten:</span><span class="sxs-lookup"><span data-stu-id="dcc54-269">Later sections that deal with individual storage services discuss scalability targets in the context of that specific service:</span></span>  

* [<span data-ttu-id="dcc54-270">BLOB-bandbredd och begäranden per sekund</span><span class="sxs-lookup"><span data-stu-id="dcc54-270">Blob bandwidth and requests per second</span></span>](#subheading16)
* [<span data-ttu-id="dcc54-271">Tabellentiteter per sekund</span><span class="sxs-lookup"><span data-stu-id="dcc54-271">Table entities per second</span></span>](#subheading24)
* [<span data-ttu-id="dcc54-272">Kömeddelanden per sekund</span><span class="sxs-lookup"><span data-stu-id="dcc54-272">Queue messages per second</span></span>](#subheading39)  

#### <span data-ttu-id="dcc54-273"><a name="sub1bandwidth"></a>Bandbredd skalbarhet mål för alla tjänster</span><span class="sxs-lookup"><span data-stu-id="dcc54-273"><a name="sub1bandwidth"></a>Bandwidth Scalability Target for All Services</span></span>
<span data-ttu-id="dcc54-274">Vid tidpunkten för skrivning är bandbredd mål i USA för ett konto med geo-redundant lagring (GRS) 10 Gigabit per sekund (Gbps) för inkommande trafik (data som skickas till lagringskontot) och 20 Gbit/s för utgående trafik (data som skickas från storage-konto).</span><span class="sxs-lookup"><span data-stu-id="dcc54-274">At the time of writing, the bandwidth targets in the US for a geo-redundant storage (GRS) account are 10 gigabits per second (Gbps) for ingress (data sent to the storage account) and 20 Gbps for egress (data sent from the storage account).</span></span> <span data-ttu-id="dcc54-275">För ett lokalt redundant lagringskonto (LRS) gränserna som är högre – 20 Gbit/s för ingående och 30 Gbit/s för utgående trafik.</span><span class="sxs-lookup"><span data-stu-id="dcc54-275">For a locally redundant storage (LRS) account, the limits are higher – 20 Gbps for ingress and 30 Gbps for egress.</span></span>  <span data-ttu-id="dcc54-276">Internationella bandbreddsgränser kan vara lägre och finns på vår [skalbarhet mål sidan](http://msdn.microsoft.com/library/azure/dn249410.aspx).</span><span class="sxs-lookup"><span data-stu-id="dcc54-276">International bandwidth limits may be lower and can be found on our [scalability targets page](http://msdn.microsoft.com/library/azure/dn249410.aspx).</span></span>  <span data-ttu-id="dcc54-277">Mer information om lagringsalternativ för redundans finns i [användbara resurser](#sub1useful) nedan.</span><span class="sxs-lookup"><span data-stu-id="dcc54-277">For more information on the storage redundancy options, see the links in [Useful Resources](#sub1useful) below.</span></span>  

#### <a name="what-to-do-when-approaching-a-scalability-target"></a><span data-ttu-id="dcc54-278">Vad gör närmar sig ett mål för skalbarhet</span><span class="sxs-lookup"><span data-stu-id="dcc54-278">What to do when approaching a scalability target</span></span>
<span data-ttu-id="dcc54-279">Om ditt program närmar sig skalbarhetsmål för ett enda lagringskonto, bör du införandet av en av följande metoder:</span><span class="sxs-lookup"><span data-stu-id="dcc54-279">If your application is approaching the scalability targets for a single storage account, consider adopting one of the following approaches:</span></span>  

* <span data-ttu-id="dcc54-280">Ändra den arbetsbelastning som gör att programmet till närmar sig eller överskrider skalbarhet målet.</span><span class="sxs-lookup"><span data-stu-id="dcc54-280">Reconsider the workload that causes your application to approach or exceed the scalability target.</span></span> <span data-ttu-id="dcc54-281">Kan du utforma på olika sätt att använda mindre bandbredd eller kapacitet eller färre transaktioner?</span><span class="sxs-lookup"><span data-stu-id="dcc54-281">Can you design it differently to use less bandwidth or capacity, or fewer transactions?</span></span>
* <span data-ttu-id="dcc54-282">Om ett program måste överskrider ett av målen för skalbarhet, bör du skapa flera lagringskonton och partition dina programdata mellan dessa flera lagringskonton.</span><span class="sxs-lookup"><span data-stu-id="dcc54-282">If an application must exceed one of the scalability targets, you should create multiple storage accounts and partition your application data across those multiple storage accounts.</span></span> <span data-ttu-id="dcc54-283">Om du använder det här mönstret sedan bör du utforma ditt program så att du kan lägga till flera lagringskonton i framtiden för belastningsutjämning.</span><span class="sxs-lookup"><span data-stu-id="dcc54-283">If you use this pattern, then be sure to design your application so that you can add more storage accounts in the future for load balancing.</span></span> <span data-ttu-id="dcc54-284">Varje Azure-prenumeration kan ha upp till 100 lagringskonton vid tiden för skrivning.</span><span class="sxs-lookup"><span data-stu-id="dcc54-284">At time of writing, each Azure subscription can have up to 100 storage accounts.</span></span>  <span data-ttu-id="dcc54-285">Storage-konton har också utan kostnad än förbrukningen termer data som lagras, transaktioner som har gjorts eller data som överförs.</span><span class="sxs-lookup"><span data-stu-id="dcc54-285">Storage accounts also have no cost other than your usage in terms of data stored, transactions made, or data transferred.</span></span>
* <span data-ttu-id="dcc54-286">Om ditt program träffar bandbredd mål, Överväg att komprimera data i klienten och minska den bandbredd som krävs för att skicka data till storage-tjänst.</span><span class="sxs-lookup"><span data-stu-id="dcc54-286">If your application hits the bandwidth targets, consider compressing data in the client to reduce the bandwidth required to send the data to the storage service.</span></span>  <span data-ttu-id="dcc54-287">Observera att även om detta kan spara bandbredd och förbättra nätverkets prestanda, den kan också innehålla några negativa konsekvenser.</span><span class="sxs-lookup"><span data-stu-id="dcc54-287">Note that while this may save bandwidth and improve network performance, it can also have some negative impacts.</span></span>  <span data-ttu-id="dcc54-288">Du bör utvärdera prestandapåverkan detta på grund av ytterligare bearbetning kraven för att komprimera och expandera data på klienten.</span><span class="sxs-lookup"><span data-stu-id="dcc54-288">You should evaluate the performance impact of this due to the additional processing requirements for compressing and decompressing data in the client.</span></span> <span data-ttu-id="dcc54-289">Dessutom kan kan lagra komprimerade data göra det svårare att felsöka problem Eftersom det kan vara svårare att visa lagrade data med standardverktyg.</span><span class="sxs-lookup"><span data-stu-id="dcc54-289">In addition, storing compressed data can make it more difficult to troubleshoot issues since it could be more difficult to view stored data using standard tools.</span></span>
* <span data-ttu-id="dcc54-290">Om ditt program träffar skalbarhetsmål, kontrollera att du använder en exponentiell backoff för återförsök (se [återförsök](#subheading14)).</span><span class="sxs-lookup"><span data-stu-id="dcc54-290">If your application hits the scalability targets, then ensure that you are using an exponential backoff for retries (see [Retries](#subheading14)).</span></span>  <span data-ttu-id="dcc54-291">Det är bättre att se till att du aldrig närmar sig skalbarhetsmål (med hjälp av en av metoderna ovan), men det säkerställer att programmet inte bara att fortsätta försöka snabbt, vilket gör begränsningen värre.</span><span class="sxs-lookup"><span data-stu-id="dcc54-291">It's better to make sure you never approach the scalability targets (by using one of the above methods), but this will ensure your application won't just keep retrying rapidly, making the throttling worse.</span></span>  

#### <a name="useful-resources"></a><span data-ttu-id="dcc54-292">Användbara resurser</span><span class="sxs-lookup"><span data-stu-id="dcc54-292">Useful Resources</span></span>
<span data-ttu-id="dcc54-293">Följande länkar innehåller ytterligare information om skalbarhetsmål:</span><span class="sxs-lookup"><span data-stu-id="dcc54-293">The following links provide additional detail on scalability targets:</span></span>

* <span data-ttu-id="dcc54-294">Se [Azure Storage skalbarhets- och prestandamål](storage-scalability-targets.md) information om skalbarhetsmål.</span><span class="sxs-lookup"><span data-stu-id="dcc54-294">See [Azure Storage Scalability and Performance Targets](storage-scalability-targets.md) for information about scalability targets.</span></span>
* <span data-ttu-id="dcc54-295">Se [Azure Storage-replikering](storage-redundancy.md) och blogginlägget [Azure lagringsalternativ för redundans och Geo-Redundant lagring med läsbehörighet](http://blogs.msdn.com/b/windowsazurestorage/archive/2013/12/11/introducing-read-access-geo-replicated-storage-ra-grs-for-windows-azure-storage.aspx) information om lagringsalternativ för redundans.</span><span class="sxs-lookup"><span data-stu-id="dcc54-295">See [Azure Storage replication](storage-redundancy.md) and the blog post [Azure Storage Redundancy Options and Read Access Geo Redundant Storage](http://blogs.msdn.com/b/windowsazurestorage/archive/2013/12/11/introducing-read-access-geo-replicated-storage-ra-grs-for-windows-azure-storage.aspx) for information about storage redundancy options.</span></span>
* <span data-ttu-id="dcc54-296">Aktuell information om priser för Azure-tjänster finns [priser för Azure](https://azure.microsoft.com/pricing/overview/).</span><span class="sxs-lookup"><span data-stu-id="dcc54-296">For current information about pricing for Azure services, see [Azure pricing](https://azure.microsoft.com/pricing/overview/).</span></span>  

### <span data-ttu-id="dcc54-297"><a name="subheading47"></a>Namngivningskonventionen för partition</span><span class="sxs-lookup"><span data-stu-id="dcc54-297"><a name="subheading47"></a>Partition Naming Convention</span></span>
<span data-ttu-id="dcc54-298">Azure Storage använder ett intervall-baserade partitioneringsschema skalning och inläsning balans i systemet.</span><span class="sxs-lookup"><span data-stu-id="dcc54-298">Azure Storage uses a range-based partitioning scheme to scale and load balance the system.</span></span> <span data-ttu-id="dcc54-299">Partitionsnyckeln används för att partitionera data till intervall och dessa områden är belastningsutjämnad hela systemet.</span><span class="sxs-lookup"><span data-stu-id="dcc54-299">The partition key is used to partition data into ranges and these ranges are load-balanced across the system.</span></span> <span data-ttu-id="dcc54-300">Detta innebär namngivningskonventioner, till exempel lexikala ordning (t.ex. msftpayroll, msftperformance, msftemployees osv.) eller med tidsstämplar (log20160101, log20160102, log20160102 osv.) kan låna ut sig själva partitioner som potentiellt är placerade på samma server partition, förrän en NLB åtgärden delar ut dem i mindre intervall.</span><span class="sxs-lookup"><span data-stu-id="dcc54-300">This means naming conventions such as lexical ordering (e.g. msftpayroll, msftperformance, msftemployees, etc) or using time-stamps (log20160101, log20160102, log20160102, etc) will lend itself to the partitions being potentially co-located on the same partition server, until a load balancing operation splits them out into smaller ranges.</span></span> <span data-ttu-id="dcc54-301">Alla blobbar i en behållare kan till exempel hanteras av en enskild server förrän belastningen på dessa blobbar kräver ytterligare omfördelning av partition intervall.</span><span class="sxs-lookup"><span data-stu-id="dcc54-301">For example, all blobs within a container can be served by a single server until the load on these blobs requires further rebalancing of the partition ranges.</span></span> <span data-ttu-id="dcc54-302">På samma sätt kan en grupp med lågt belastade konton med namnen i lexikala ordning kan hanteras av en enskild server förrän belastningen på en eller alla dessa konton behöver dem för att delas upp på flera servrar i partitioner.</span><span class="sxs-lookup"><span data-stu-id="dcc54-302">Similarly, a group of lightly loaded accounts with their names arranged in lexical order may be served by a single server until the load on one or all of these accounts require them to be split across multiple partitions servers.</span></span> <span data-ttu-id="dcc54-303">Varje belastningsutjämningsregel åtgärden kan påverka svarstiden för lagring anrop under åtgärden.</span><span class="sxs-lookup"><span data-stu-id="dcc54-303">Each load balancing operation may impact the latency of storage calls during the operation.</span></span> <span data-ttu-id="dcc54-304">Systemets möjlighet att hantera en plötslig burst av trafik till en partition begränsas av skalbarhet i en enda partition server förrän åtgärden för belastningsutjämning sparkar i och balanserar partitionsnyckelintervallet.</span><span class="sxs-lookup"><span data-stu-id="dcc54-304">The system's ability to handle a sudden burst of traffic to a partition is limited by the scalability of a single partition server until the load balancing operation kicks-in and rebalances the partition key range.</span></span>  

<span data-ttu-id="dcc54-305">Du kan följa några metoder för att minska frekvensen av dessa åtgärder.</span><span class="sxs-lookup"><span data-stu-id="dcc54-305">You can follow some best practices to reduce the frequency of such operations.</span></span>  

* <span data-ttu-id="dcc54-306">Granska namngivningskonvention som du använder för konton, behållare, blobbar, tabeller och köer, nära.</span><span class="sxs-lookup"><span data-stu-id="dcc54-306">Examine the naming convention you use for accounts, containers, blobs, tables and queues, closely.</span></span> <span data-ttu-id="dcc54-307">Du skapar prefix kontonamn med ett 3-siffriga hash-värde med hjälp av en hash-funktionen som bäst passar dina behov.</span><span class="sxs-lookup"><span data-stu-id="dcc54-307">Consider prefixing account names with a 3-digit hash using a hashing function that best suits your needs.</span></span>  
* <span data-ttu-id="dcc54-308">Om du organisera dina data med tidsstämplar eller numerisk identifierare, måste du se till att du inte använder en append-only (eller endast lägga) trafikmönster.</span><span class="sxs-lookup"><span data-stu-id="dcc54-308">If you organize your data using timestamps or numerical identifiers, you have to ensure you are not using an append-only (or prepend-only) traffic patterns.</span></span> <span data-ttu-id="dcc54-309">Dessa mönster lämpar sig inte för ett intervall-baserade partitionering system och kan leda till all trafik som kommer att en enskild partition och begränsa system från effektivt belastningsutjämning.</span><span class="sxs-lookup"><span data-stu-id="dcc54-309">These patterns are not suitable for a range -based partitioning system, and could lead to all the traffic going to a single partition and limiting the system from effectively load balancing.</span></span> <span data-ttu-id="dcc54-310">Till exempel om du har dagliga åtgärder som använder ett blob-objekt med en tidsstämpel, till exempel ÅÅÅÅMMDD omdirigeras sedan all trafik för den dagliga driften till ett enda objekt som hanteras av en enda partition-servern.</span><span class="sxs-lookup"><span data-stu-id="dcc54-310">For instance, if you have daily operations that use a blob object with a timestamp such as yyyymmdd, then all the traffic for that daily operation is directed to a single object which is served by a single partition server.</span></span> <span data-ttu-id="dcc54-311">Titta på om den per blob gränser och partition gränser uppfyller dina behov och kan du dela den här åtgärden i flera blobbar om det behövs.</span><span class="sxs-lookup"><span data-stu-id="dcc54-311">Look at whether the per blob limits and per partition limits meet your needs, and consider breaking this operation into multiple blobs if needed.</span></span> <span data-ttu-id="dcc54-312">På samma sätt om du sparar tid series-data i tabeller dirigeras alla trafiken kan vara till den senaste del av nyckeln namnområdet.</span><span class="sxs-lookup"><span data-stu-id="dcc54-312">Similarly, if you store time series data in your tables, all the traffic could be directed to the last part of the key namespace.</span></span> <span data-ttu-id="dcc54-313">Om du måste använda tidsstämplar eller numeriska ID, prefix prefix id med 3-siffriga hash eller tidsstämplar sekunder en del av tid som ssyyyymmdd.</span><span class="sxs-lookup"><span data-stu-id="dcc54-313">If you must use timestamps or numerical IDs, prefix the id with a 3-digit hash, or in the case of timestamps prefix the seconds part of the time such as ssyyyymmdd.</span></span> <span data-ttu-id="dcc54-314">Visa och undersöka åtgärder utförs regelbundet, välja en hash-funktionen som begränsar antalet frågor.</span><span class="sxs-lookup"><span data-stu-id="dcc54-314">If listing and querying operations are routinely performed, choose a hashing function that will limit your number of queries.</span></span> <span data-ttu-id="dcc54-315">I annat fall kan en slumpmässig prefixet vara tillräckligt.</span><span class="sxs-lookup"><span data-stu-id="dcc54-315">In other cases, a random prefix may be sufficient.</span></span>  
* <span data-ttu-id="dcc54-316">För ytterligare information om partitioneringsschema används i Azure Storage, läsa SOSP paper [här](http://sigops.org/sosp/sosp11/current/2011-Cascais/printable/11-calder.pdf).</span><span class="sxs-lookup"><span data-stu-id="dcc54-316">For additional information on the partitioning scheme used in Azure Storage, read the SOSP paper [here](http://sigops.org/sosp/sosp11/current/2011-Cascais/printable/11-calder.pdf).</span></span>

### <a name="networking"></a><span data-ttu-id="dcc54-317">Nätverk</span><span class="sxs-lookup"><span data-stu-id="dcc54-317">Networking</span></span>
<span data-ttu-id="dcc54-318">När API-anrop frågan, har fysiska nätverksbegränsningar i programmet ofta en betydande inverkan på prestanda.</span><span class="sxs-lookup"><span data-stu-id="dcc54-318">While the API calls matter, often the physical network constraints of the application have a significant impact on performance.</span></span> <span data-ttu-id="dcc54-319">Nedan beskrivs några begränsningar kan användarna få.</span><span class="sxs-lookup"><span data-stu-id="dcc54-319">The following describe some of limitations users may encounter.</span></span>  

#### <a name="client-network-capability"></a><span data-ttu-id="dcc54-320">Klienten nätverkskapacitet</span><span class="sxs-lookup"><span data-stu-id="dcc54-320">Client Network Capability</span></span>
##### <span data-ttu-id="dcc54-321"><a name="subheading2"></a>Dataflöde</span><span class="sxs-lookup"><span data-stu-id="dcc54-321"><a name="subheading2"></a>Throughput</span></span>
<span data-ttu-id="dcc54-322">Problemet är ofta funktionerna i klienten för bandbredd.</span><span class="sxs-lookup"><span data-stu-id="dcc54-322">For bandwidth, the problem is often the capabilities of the client.</span></span> <span data-ttu-id="dcc54-323">Till exempel när ett enda storage-konto kan hantera 10 Gbit/s eller flera av ingång (se [bandbredd skalbarhetsmål](#sub1bandwidth)), nätverkshastigheten i en instans av ”liten” Azure-Arbetsroll kan endast cirka 100 Mbit/s.</span><span class="sxs-lookup"><span data-stu-id="dcc54-323">For example, while a single storage account can handle 10 Gbps or more of ingress (see [bandwidth scalability targets](#sub1bandwidth)), the network speed in a "Small" Azure Worker Role instance is only capable of approximately 100 Mbps.</span></span> <span data-ttu-id="dcc54-324">Större Azure-instanser har nätverkskort med större kapacitet, så bör du använda en större instans eller flera Virtuella datorer om du behöver högre gränser i nätverket från en enda dator.</span><span class="sxs-lookup"><span data-stu-id="dcc54-324">Larger Azure instances have NICs with greater capacity, so you should consider using a larger instance or more VM's if you need higher network limits from a single machine.</span></span> <span data-ttu-id="dcc54-325">Om du ansluter till en Storage-tjänst från ett på lokala program och samma sak gäller: Förstå nätverksfunktioner på klientenheten och nätverksanslutningen till lagringsplatsen för Azure och antingen förbättra dem som behövs eller designa programmet att fungera inom deras funktioner.</span><span class="sxs-lookup"><span data-stu-id="dcc54-325">If you are accessing a Storage service from an on premises application, then the same rule applies: understand the network capabilities of the client device and the network connectivity to the Azure Storage location and either improve them as needed or design your application to work within their capabilities.</span></span>  

##### <span data-ttu-id="dcc54-326"><a name="subheading3"></a>Länkkvalitet</span><span class="sxs-lookup"><span data-stu-id="dcc54-326"><a name="subheading3"></a>Link Quality</span></span>
<span data-ttu-id="dcc54-327">Precis som med alla nätverksanvändning Tänk på att nätverksförhållanden ledde till ett fel och paketförlust kommer långsamma effektiva genomflöde.</span><span class="sxs-lookup"><span data-stu-id="dcc54-327">As with any network usage, be aware that network conditions resulting in errors and packet loss will slow effective throughput.</span></span>  <span data-ttu-id="dcc54-328">WireShark eller NetMon hjälp kan lösa problemet.</span><span class="sxs-lookup"><span data-stu-id="dcc54-328">Using WireShark or NetMon may help in diagnosing this issue.</span></span>  

##### <a name="useful-resources"></a><span data-ttu-id="dcc54-329">Användbara resurser</span><span class="sxs-lookup"><span data-stu-id="dcc54-329">Useful Resources</span></span>
<span data-ttu-id="dcc54-330">Mer information om storlekar för virtuella datorer och allokerad bandbredd finns [Windows VM-storlekar](../../virtual-machines/windows/sizes.md?toc=%2fazure%2fvirtual-machines%2fwindows%2ftoc.json) eller [Linux VM-storlekar](../../virtual-machines/windows/sizes.md?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json).</span><span class="sxs-lookup"><span data-stu-id="dcc54-330">For more information about virtual machine sizes and allocated bandwidth, see [Windows VM sizes](../../virtual-machines/windows/sizes.md?toc=%2fazure%2fvirtual-machines%2fwindows%2ftoc.json) or [Linux VM sizes](../../virtual-machines/windows/sizes.md?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json).</span></span>  

#### <span data-ttu-id="dcc54-331"><a name="subheading4"></a>Plats</span><span class="sxs-lookup"><span data-stu-id="dcc54-331"><a name="subheading4"></a>Location</span></span>
<span data-ttu-id="dcc54-332">I en distribuerad miljö ger placerar klienten nära servern bästa prestanda.</span><span class="sxs-lookup"><span data-stu-id="dcc54-332">In any distributed environment, placing the client near to the server delivers in the best performance.</span></span> <span data-ttu-id="dcc54-333">För att komma åt Azure Storage med den lägsta fördröjningen är den bästa platsen för din klient inom samma Azure-region.</span><span class="sxs-lookup"><span data-stu-id="dcc54-333">For accessing Azure Storage with the lowest latency, the best location for your client is within the same Azure region.</span></span> <span data-ttu-id="dcc54-334">Till exempel om du har en Azure-webbplats som använder Azure Storage kan du söka efter dem båda inom en enskild region (till exempel oss Väst eller Asien/Stillahavsområdet, sydost).</span><span class="sxs-lookup"><span data-stu-id="dcc54-334">For example, if you have an Azure Web Site that uses Azure Storage, you should locate them both within a single region (for example, US West or Asia Southeast).</span></span> <span data-ttu-id="dcc54-335">Detta minskar svarstiden och kostnaden – vid tidpunkten för skrivning bandbreddsanvändning inom en enskild region är ledig.</span><span class="sxs-lookup"><span data-stu-id="dcc54-335">This reduces the latency and the cost — at the time of writing, bandwidth usage within a single region is free.</span></span>  

<span data-ttu-id="dcc54-336">Om klienten program inte finns i Azure (till exempel appar för mobila enheter eller lokala företagstjänster), sedan igen placerar storage-konto i en region nära de enheter som kommer åt, vanligtvis minskar latens.</span><span class="sxs-lookup"><span data-stu-id="dcc54-336">If your client applications are not hosted within Azure (such as mobile device apps or on premises enterprise services), then again placing the storage account in a region near to the devices that will access it, will generally reduce latency.</span></span> <span data-ttu-id="dcc54-337">Om klienterna distribueras brett (till exempel, en del i Nordamerika och vissa i Europa), så bör du använda flera lagringskonton: placerad i Nordamerika region och en i en europeisk region.</span><span class="sxs-lookup"><span data-stu-id="dcc54-337">If your clients are broadly distributed (for example, some in North America, and some in Europe), then you should consider using multiple storage accounts: one located in a North American region and one in a European region.</span></span> <span data-ttu-id="dcc54-338">Detta hjälper till att minska svarstiden för användare i båda regioner.</span><span class="sxs-lookup"><span data-stu-id="dcc54-338">This will help to reduce latency for users in both regions.</span></span> <span data-ttu-id="dcc54-339">Den här metoden är vanligtvis enklare att implementera om data programmet lagrar är specifik för enskilda användare och kräver inte replikerar data mellan lagringskonton.</span><span class="sxs-lookup"><span data-stu-id="dcc54-339">This approach is usually easier to implement if the data the application stores is specific to individual users, and does not require replicating data between storage accounts.</span></span>  <span data-ttu-id="dcc54-340">En CDN rekommenderas för bred innehållsdistribution – finns i nästa avsnitt för mer information.</span><span class="sxs-lookup"><span data-stu-id="dcc54-340">For broad content distribution, a CDN is recommended – see the next section for more details.</span></span>  

### <span data-ttu-id="dcc54-341"><a name="subheading5"></a>Innehållsdistribution</span><span class="sxs-lookup"><span data-stu-id="dcc54-341"><a name="subheading5"></a>Content Distribution</span></span>
<span data-ttu-id="dcc54-342">Ibland kan behöver ett program hantera samma innehåll till flera användare (t.ex. en produkt demonstrationsvideon används i startsidan för en webbplats), finns i samma eller flera regioner.</span><span class="sxs-lookup"><span data-stu-id="dcc54-342">Sometimes, an application needs to serve the same content to many users (e.g. a product demo video used in the home page of a website), located in either the same or multiple regions.</span></span> <span data-ttu-id="dcc54-343">I det här scenariot bör du använda en innehåll innehållsleveransnätverk (CDN), till exempel Azure CDN och CDN ska använda Azure storage startpunkt som data.</span><span class="sxs-lookup"><span data-stu-id="dcc54-343">In this scenario, you should use a Content Delivery Network (CDN) such as Azure CDN, and the CDN would use Azure storage as the origin of the data.</span></span> <span data-ttu-id="dcc54-344">Till skillnad från ett Azure Storage-konto som finns i en region och som det går inte att leverera innehåll med låg latens till andra regioner använder Azure CDN-servrar i flera Datacenter runtom i världen.</span><span class="sxs-lookup"><span data-stu-id="dcc54-344">Unlike an Azure Storage account that exists in a single region and that cannot deliver content with low latency to other regions, Azure CDN uses servers in multiple data centers around the world.</span></span> <span data-ttu-id="dcc54-345">Dessutom kan en CDN vanligtvis stöder mycket högre utgång gränser än ett enda storage-konto.</span><span class="sxs-lookup"><span data-stu-id="dcc54-345">Additionally, a CDN can typically support much higher egress limits than a single storage account.</span></span>  

<span data-ttu-id="dcc54-346">Mer information om Azure CDN finns [Azure CDN](https://azure.microsoft.com/services/cdn/).</span><span class="sxs-lookup"><span data-stu-id="dcc54-346">For more information about Azure CDN, see [Azure CDN](https://azure.microsoft.com/services/cdn/).</span></span>  

### <span data-ttu-id="dcc54-347"><a name="subheading6"></a>Med hjälp av SAS och CORS</span><span class="sxs-lookup"><span data-stu-id="dcc54-347"><a name="subheading6"></a>Using SAS and CORS</span></span>
<span data-ttu-id="dcc54-348">När du vill tillåta kod exempelvis JavaScript i webbläsare för en användare eller en mobiltelefon-app för att komma åt data i Azure Storage, en metod är att använda ett program i webbroll som en proxy: användarens enhet autentiseras med webbrollen, som i sin tur autentiserar med storage-tjänst.</span><span class="sxs-lookup"><span data-stu-id="dcc54-348">When you need to authorize code such as JavaScript in a user's web browser or a mobile phone app to access data in Azure Storage, one approach is to use an application in web role as a proxy: the user's device authenticates with the web role, which in turn authenticates with the storage service.</span></span> <span data-ttu-id="dcc54-349">På så sätt kan undvika du att exponera dina lagringskontonycklar på osäker enheter.</span><span class="sxs-lookup"><span data-stu-id="dcc54-349">In this way, you can avoid exposing your storage account keys on insecure devices.</span></span> <span data-ttu-id="dcc54-350">Men placerar detta en stor belastning på webbrollen eftersom alla data som överförs mellan enheten och lagringstjänsten måste passera webbrollen.</span><span class="sxs-lookup"><span data-stu-id="dcc54-350">However, this places a big overhead on the web role because all the data transferred between the user's device and the storage service must pass through the web role.</span></span> <span data-ttu-id="dcc54-351">Du kan undvika att använda en webbroll som en proxy för lagringstjänsten med delad åtkomst signaturer (SAS), ibland tillsammans med rubriker om Cross-Origin Resource Sharing (CORS).</span><span class="sxs-lookup"><span data-stu-id="dcc54-351">You can avoid using a web role as a proxy for the storage service by using Shared Access Signatures (SAS), sometimes in conjunction with Cross-Origin Resource Sharing headers (CORS).</span></span> <span data-ttu-id="dcc54-352">Med SAS kan tillåta du användaren att göra förfrågningar direkt till en lagringstjänst med hjälp av en begränsad åtkomst-token.</span><span class="sxs-lookup"><span data-stu-id="dcc54-352">Using SAS, you can allow your user's device to make requests directly to a storage service by means of a limited access token.</span></span> <span data-ttu-id="dcc54-353">Till exempel om en användare vill överför en bild till ditt program, kan web-roll generera och skicka till användarens enhet en SAS-token som ger behörighet att skriva till en specifik blobb eller en behållare för de kommande 30 minuterna (efter vilken SAS-token upphör att gälla).</span><span class="sxs-lookup"><span data-stu-id="dcc54-353">For example, if a user wants to upload a photo to your application, your web role can generate and send to the user's device a SAS token that grants permission to write to a specific blob or container for the next 30 minutes (after which the SAS token expires).</span></span>

<span data-ttu-id="dcc54-354">En webbläsare kan normalt inte JavaScript på en sida som en webbplats på en domän att utföra specifika åtgärder som en ”PLACERA” till en annan domän som värd.</span><span class="sxs-lookup"><span data-stu-id="dcc54-354">Normally, a browser will not allow JavaScript in a page hosted by a website on one domain to perform specific operations such as a "PUT" to another domain.</span></span> <span data-ttu-id="dcc54-355">Om du är värd en webbroll på ”contosomarketing.cloudapp.net”, och vill använda client side JavaScript för att ladda upp en blob storage-konto på ”contosoproducts.blob.core.windows.net”, webbläsarens exempelvis ”samma ursprung policy” kommer förbjuda den här åtgärden.</span><span class="sxs-lookup"><span data-stu-id="dcc54-355">For example, if you host a web role at "contosomarketing.cloudapp.net," and want to use client side JavaScript to upload a blob to your storage account at "contosoproducts.blob.core.windows.net," the browser's "same origin policy" will forbid this operation.</span></span> <span data-ttu-id="dcc54-356">CORS är en webbläsarfunktion som tillåter måldomänen (i det här fallet lagringskontot) för att kommunicera med webbläsaren att den litar på begäranden med ursprung i källdomänen (i det här fallet webbrollen).</span><span class="sxs-lookup"><span data-stu-id="dcc54-356">CORS is a browser feature that allows the target domain (in this case the storage account) to communicate to the browser that it trusts requests originating in the source domain (in this case the web role).</span></span>  

<span data-ttu-id="dcc54-357">Båda dessa tekniker kan hjälpa dig att undvika onödiga belastning (och flaskhalsar) på ditt webbprogram.</span><span class="sxs-lookup"><span data-stu-id="dcc54-357">Both of these technologies can help you avoid unnecessary load (and bottlenecks) on your web application.</span></span>  

#### <a name="useful-resources"></a><span data-ttu-id="dcc54-358">Användbara resurser</span><span class="sxs-lookup"><span data-stu-id="dcc54-358">Useful Resources</span></span>
<span data-ttu-id="dcc54-359">Mer information om SAS finns [signaturer för delad åtkomst, del 1: Förstå SAS-modellen](../storage-dotnet-shared-access-signature-part-1.md).</span><span class="sxs-lookup"><span data-stu-id="dcc54-359">For more information about SAS, see [Shared Access Signatures, Part 1: Understanding the SAS Model](../storage-dotnet-shared-access-signature-part-1.md).</span></span>  

<span data-ttu-id="dcc54-360">Läs mer om CORS [Cross-Origin Resource Sharing (CORS) stöd för Azure Storage-tjänster](http://msdn.microsoft.com/library/azure/dn535601.aspx).</span><span class="sxs-lookup"><span data-stu-id="dcc54-360">For more information about CORS, see [Cross-Origin Resource Sharing (CORS) Support for the Azure Storage Services](http://msdn.microsoft.com/library/azure/dn535601.aspx).</span></span>  

### <a name="caching"></a><span data-ttu-id="dcc54-361">Cachelagring</span><span class="sxs-lookup"><span data-stu-id="dcc54-361">Caching</span></span>
#### <span data-ttu-id="dcc54-362"><a name="subheading7"></a>Hämtning av Data</span><span class="sxs-lookup"><span data-stu-id="dcc54-362"><a name="subheading7"></a>Getting Data</span></span>
<span data-ttu-id="dcc54-363">I allmänhet är hämtar data från en tjänst när bättre än tas den två gånger.</span><span class="sxs-lookup"><span data-stu-id="dcc54-363">In general, getting data from a service once is better than getting it twice.</span></span> <span data-ttu-id="dcc54-364">Studera exemplet som en MVC-webbapp körs i en webbroll som har redan hämtas en 50MB blob storage-tjänst som fungerar som innehåll till en användare.</span><span class="sxs-lookup"><span data-stu-id="dcc54-364">Consider the example of an MVC web application running in a web role that has already retrieved a 50MB blob from the storage service to serve as content to a user.</span></span> <span data-ttu-id="dcc54-365">Programmet kan sedan hämta samma blobben varje gång en användare begär den eller det kan cachelagra den lokalt disken och återanvända den cachelagrade versionen för efterföljande användarförfrågningar.</span><span class="sxs-lookup"><span data-stu-id="dcc54-365">The application could then retrieve that same blob every time a user requests it, or it could cache it locally to disk and reuse the cached version for subsequent user requests.</span></span> <span data-ttu-id="dcc54-366">Dessutom, när en användare begär data, programmet kan problemet får med ett villkorat huvud för ändringstid som skulle undvika hela blobben om den inte har ändrats.</span><span class="sxs-lookup"><span data-stu-id="dcc54-366">Furthermore, whenever a user requests the data, the application could issue GET with a conditional header for modification time, which would avoid getting the entire blob if it hasn't been modified.</span></span> <span data-ttu-id="dcc54-367">Du kan använda den här samma mönster för att arbeta med tabellentiteter.</span><span class="sxs-lookup"><span data-stu-id="dcc54-367">You can apply this same pattern to working with table entities.</span></span>  

<span data-ttu-id="dcc54-368">I vissa fall kan du välja att programmet kan anta att blob förblir giltigt under en kort period efter hämtning av det och att under denna tid programmet inte behöver kontrollera om blob har ändrats.</span><span class="sxs-lookup"><span data-stu-id="dcc54-368">In some cases, you may decide that your application can assume that the blob remains valid for a short period after retrieving it, and that during this period the application does not need to check if the blob was modified.</span></span>

<span data-ttu-id="dcc54-369">Konfiguration, sökning och andra data som används alltid av programmet är bra kandidater för cachelagring.</span><span class="sxs-lookup"><span data-stu-id="dcc54-369">Configuration, lookup, and other data that are always used by the application are great candidates for caching.</span></span>  

<span data-ttu-id="dcc54-370">Ett exempel på hur en blob-egenskaper för att identifiera senaste ändringsdatum med hjälp av .NET finns [Set och hämta egenskaper och Metadata](../blobs/storage-properties-metadata.md).</span><span class="sxs-lookup"><span data-stu-id="dcc54-370">For an example of how to get a blob's properties to discover the last modified date using .NET, see [Set and Retrieve Properties and Metadata](../blobs/storage-properties-metadata.md).</span></span> <span data-ttu-id="dcc54-371">Mer information om nedladdningar av villkorlig finns [villkorligt uppdatera en lokal kopia av en Blob](http://msdn.microsoft.com/library/azure/dd179371.aspx).</span><span class="sxs-lookup"><span data-stu-id="dcc54-371">For more information about conditional downloads, see [Conditionally Refresh a Local Copy of a Blob](http://msdn.microsoft.com/library/azure/dd179371.aspx).</span></span>  

#### <span data-ttu-id="dcc54-372"><a name="subheading8"></a>Ladda upp Data i batchar</span><span class="sxs-lookup"><span data-stu-id="dcc54-372"><a name="subheading8"></a>Uploading Data in Batches</span></span>
<span data-ttu-id="dcc54-373">I vissa program, kan aggregera data lokalt och sedan regelbundet ladda upp den i en grupp i stället för att överföra varje datadel omedelbart.</span><span class="sxs-lookup"><span data-stu-id="dcc54-373">In some application scenarios, you can aggregate data locally, and then periodically upload it in a batch instead of uploading each piece of data immediately.</span></span> <span data-ttu-id="dcc54-374">Till exempel ett webbprogram ha en loggfil över aktiviteter: programmet kan antingen ladda upp information om varje aktivitet som det sker som en tabell-enhet (som kräver många lagringsåtgärder) eller så kan spara information om datoraktivitet till en lokal loggfil och sedan överföra alla aktivitetsinformation regelbundet som en avgränsad fil till en blobb.</span><span class="sxs-lookup"><span data-stu-id="dcc54-374">For example, a web application might keep a log file of activities: the application could either upload details of every activity as it happens as a table entity (which requires many storage operations), or it could save activity details to a local log file, and then periodically upload all activity details as a delimited file to a blob.</span></span> <span data-ttu-id="dcc54-375">Om varje loggpost är 1KB i storlek, kan du överföra tusentalsavgränsare i en enda transaktion för ”placera Blob” (du kan överföra en blob med upp till 64MB i storlek i en enda transaktion).</span><span class="sxs-lookup"><span data-stu-id="dcc54-375">If each log entry is 1KB in size, you can upload thousands in a single "Put Blob" transaction (you can upload a blob of up to 64MB in size in a single transaction).</span></span> <span data-ttu-id="dcc54-376">Naturligtvis, om den lokala datorn kraschar före överföringen, potentiellt förlorar du vissa loggdata: programutvecklaren måste utforma möjlighet till klientenheten eller Överför fel.</span><span class="sxs-lookup"><span data-stu-id="dcc54-376">Of course, if the local machine crashes prior to the upload, you will potentially lose some log data: the application developer must design for the possibility of client device or upload failures.</span></span>  <span data-ttu-id="dcc54-377">Om aktivitetsdata behöver laddas ner för timespans (inte bara enkel aktivitet), bör blobbar över tabeller.</span><span class="sxs-lookup"><span data-stu-id="dcc54-377">If the activity data needs to be downloaded for timespans (not just single activity), then blobs are recommended over tables.</span></span>

### <a name="net-configuration"></a><span data-ttu-id="dcc54-378">.NET-konfiguration</span><span class="sxs-lookup"><span data-stu-id="dcc54-378">.NET Configuration</span></span>
<span data-ttu-id="dcc54-379">Om du använder .NET Framework innehåller det här avsnittet flera snabb konfigurationsinställningar som du kan använda för att göra betydande prestandaförbättringar.</span><span class="sxs-lookup"><span data-stu-id="dcc54-379">If using the .NET Framework, this section lists several quick configuration settings that you can use to make significant performance improvements.</span></span>  <span data-ttu-id="dcc54-380">Om du använder andra språk, kontrollera för att se om liknande koncept som tillämpas på ditt valda språk.</span><span class="sxs-lookup"><span data-stu-id="dcc54-380">If using other languages, check to see if similar concepts apply in your chosen language.</span></span>  

#### <span data-ttu-id="dcc54-381"><a name="subheading9"></a>Öka Standardgränsen för anslutning</span><span class="sxs-lookup"><span data-stu-id="dcc54-381"><a name="subheading9"></a>Increase default connection limit</span></span>
<span data-ttu-id="dcc54-382">I .NET ökas följande kod anslutning Standardgränsen (vilket är normalt 2 i en klientmiljö med eller 10 i en servermiljö) och 100.</span><span class="sxs-lookup"><span data-stu-id="dcc54-382">In .NET, the following code increases the default connection limit (which is usually 2 in a client environment or 10 in a server environment) to 100.</span></span> <span data-ttu-id="dcc54-383">Normalt ska du ange värdet till ungefär antalet trådar som används av ditt program.</span><span class="sxs-lookup"><span data-stu-id="dcc54-383">Typically, you should set the value to approximately the number of threads used by your application.</span></span>  

```csharp
ServicePointManager.DefaultConnectionLimit = 100; //(Or More)  
```

<span data-ttu-id="dcc54-384">Du måste ange anslutningsgränsen innan du öppnar alla anslutningar.</span><span class="sxs-lookup"><span data-stu-id="dcc54-384">You must set the connection limit before opening any connections.</span></span>  

<span data-ttu-id="dcc54-385">Andra programmeringsspråk, finns i dokumentationen för det språket att fastställa hur du ställer in det angivna antalet.</span><span class="sxs-lookup"><span data-stu-id="dcc54-385">For other programming languages, see that language's documentation to determine how to set the connection limit.</span></span>  

<span data-ttu-id="dcc54-386">Mer information finns i bloggposten [Web Services: samtidiga anslutningar](http://blogs.msdn.com/b/darrenj/archive/2005/03/07/386655.aspx).</span><span class="sxs-lookup"><span data-stu-id="dcc54-386">For additional information, see the blog post [Web Services: Concurrent Connections](http://blogs.msdn.com/b/darrenj/archive/2005/03/07/386655.aspx).</span></span>  

#### <span data-ttu-id="dcc54-387"><a name="subheading10"></a>Öka ThreadPool Min Threads om synkron kod med asynkrona uppgifter</span><span class="sxs-lookup"><span data-stu-id="dcc54-387"><a name="subheading10"></a>Increase ThreadPool Min Threads if using synchronous code with Async Tasks</span></span>
<span data-ttu-id="dcc54-388">Den här koden kommer att öka tråd pool min trådar:</span><span class="sxs-lookup"><span data-stu-id="dcc54-388">This code will increase the thread pool min threads:</span></span>  

```csharp
ThreadPool.SetMinThreads(100,100); //(Determine the right number for your application)  
```

<span data-ttu-id="dcc54-389">Mer information finns i [ThreadPool.SetMinThreads metoden](http://msdn.microsoft.com/library/system.threading.threadpool.setminthreads%28v=vs.110%29.aspx).</span><span class="sxs-lookup"><span data-stu-id="dcc54-389">For more information, see [ThreadPool.SetMinThreads Method](http://msdn.microsoft.com/library/system.threading.threadpool.setminthreads%28v=vs.110%29.aspx).</span></span>  

#### <span data-ttu-id="dcc54-390"><a name="subheading11"></a>Dra nytta av .NET 4.5 skräpinsamling</span><span class="sxs-lookup"><span data-stu-id="dcc54-390"><a name="subheading11"></a>Take advantage of .NET 4.5 Garbage Collection</span></span>
<span data-ttu-id="dcc54-391">Använda .NET 4.5 eller senare för klientprogrammet för att dra nytta av bättre prestanda i server skräpinsamling.</span><span class="sxs-lookup"><span data-stu-id="dcc54-391">Use .NET 4.5 or later for the client application to take advantage of performance improvements in server garbage collection.</span></span>

<span data-ttu-id="dcc54-392">Mer information finns i artikeln [en översikt av prestandaförbättringarna i .NET 4.5](http://msdn.microsoft.com/magazine/hh882452.aspx).</span><span class="sxs-lookup"><span data-stu-id="dcc54-392">For more information, see the article [An Overview of Performance Improvements in .NET 4.5](http://msdn.microsoft.com/magazine/hh882452.aspx).</span></span>  

### <span data-ttu-id="dcc54-393"><a name="subheading12"></a>Unbounded parallellitet</span><span class="sxs-lookup"><span data-stu-id="dcc54-393"><a name="subheading12"></a>Unbounded Parallelism</span></span>
<span data-ttu-id="dcc54-394">Parallellitet kan vara bra prestanda, vara försiktig med att använda unbounded parallellitet (ingen gräns för antalet trådar och/eller parallella begäranden) att överföra eller hämta data med flera personer att få åtkomst till flera partitioner (behållare, köer eller tabellpartitioner) i samma lagringskonto eller komma åt flera objekt i samma partition.</span><span class="sxs-lookup"><span data-stu-id="dcc54-394">While parallelism can be great for performance, be careful about using unbounded parallelism (no limit on the number of threads and/or parallel requests) to upload or download data, using multiple workers to access multiple partitions (containers, queues, or table partitions) in the same storage account or to access multiple items in the same partition.</span></span> <span data-ttu-id="dcc54-395">Om parallellitet unbounded tillämpningsprogrammet kan överstiga klienten enhetsfunktioner eller storage-konto skalbarhet mål ledde till ett längre svarstider och begränsning.</span><span class="sxs-lookup"><span data-stu-id="dcc54-395">If the parallelism is unbounded, your application can exceed the client device's capabilities or the storage account's scalability targets resulting in longer latencies and throttling.</span></span>  

### <span data-ttu-id="dcc54-396"><a name="subheading13"></a>Verktyg och Storage-klientbibliotek</span><span class="sxs-lookup"><span data-stu-id="dcc54-396"><a name="subheading13"></a>Storage Client Libraries and Tools</span></span>
<span data-ttu-id="dcc54-397">Använd alltid senaste som Microsoft tillhandahåller klientbibliotek och verktyg.</span><span class="sxs-lookup"><span data-stu-id="dcc54-397">Always use the latest Microsoft provided client libraries and tools.</span></span> <span data-ttu-id="dcc54-398">Vid tidpunkten som skrivs finns klientbibliotek för .NET, Windows Phone, Windows Runtime, Java och C++ samt preview bibliotek för andra språk.</span><span class="sxs-lookup"><span data-stu-id="dcc54-398">At the time of writing, there are client libraries available for .NET, Windows Phone, Windows Runtime, Java, and C++, as well as preview libraries for other languages.</span></span> <span data-ttu-id="dcc54-399">Dessutom har Microsoft släppt PowerShell-cmdlets och Azure CLI-kommandona för att arbeta med Azure Storage.</span><span class="sxs-lookup"><span data-stu-id="dcc54-399">In addition, Microsoft has released PowerShell cmdlets and Azure CLI commands for working with Azure Storage.</span></span> <span data-ttu-id="dcc54-400">Microsoft aktivt utvecklar dessa verktyg med prestanda, för att hålla dem uppdaterade med de senaste versionerna av tjänsten och garanterar de hanterar många av aktuella beprövade prestanda internt.</span><span class="sxs-lookup"><span data-stu-id="dcc54-400">Microsoft actively develops these tools with performance in mind, keeps them up to date with the latest service versions, and ensures they handle many of the proven performance practices internally.</span></span>  

### <a name="retries"></a><span data-ttu-id="dcc54-401">Antal försök</span><span class="sxs-lookup"><span data-stu-id="dcc54-401">Retries</span></span>
#### <span data-ttu-id="dcc54-402"><a name="subheading14"></a>Begränsning/ServerBusy</span><span class="sxs-lookup"><span data-stu-id="dcc54-402"><a name="subheading14"></a>Throttling/ServerBusy</span></span>
<span data-ttu-id="dcc54-403">I vissa fall lagringstjänsten kan begränsa tillämpningsprogrammet eller helt enkelt går inte att hantera begäran på grund av vissa övergående tillstånd och returnerar meddelandet ”503 servern upptagen” eller ”tidsgräns för 500”.</span><span class="sxs-lookup"><span data-stu-id="dcc54-403">In some cases, the storage service may throttle your application or may simply be unable to serve the request due to some transient condition and return a "503 Server busy" message or "500 Timeout".</span></span>  <span data-ttu-id="dcc54-404">Detta kan inträffa om tillämpningsprogrammet närmar sig något skalbarhetsmål, eller om systemet är ombalansering partitionerade data för bättre genomströmning.</span><span class="sxs-lookup"><span data-stu-id="dcc54-404">This can happen if your application is approaching any of the scalability targets, or if the system is rebalancing your partitioned data to allow for higher throughput.</span></span>  <span data-ttu-id="dcc54-405">Klientprogrammet bör normalt gör om åtgärden som orsakar ett sådant fel: försöker samma begäran senare kan genomföras.</span><span class="sxs-lookup"><span data-stu-id="dcc54-405">The client application should typically retry the operation that causes such an error: attempting the same request later can succeed.</span></span> <span data-ttu-id="dcc54-406">Men göra om lagringstjänsten begränsning är ditt program eftersom det överskrider skalbarhetsmål eller om tjänsten kunde inte svara på begäran av någon anledning, aggressivt återförsök oftast problemet worse.</span><span class="sxs-lookup"><span data-stu-id="dcc54-406">However, if the storage service is throttling your application because it is exceeding scalability targets, or even if the service was unable to serve the request for some other reason, aggressive retries usually make the problem worse.</span></span> <span data-ttu-id="dcc54-407">Därför bör du använda en exponentiell undantagsläge (klienten bibliotek standard till det här beteendet).</span><span class="sxs-lookup"><span data-stu-id="dcc54-407">For this reason, you should use an exponential back off (the client libraries default to this behavior).</span></span> <span data-ttu-id="dcc54-408">Programmet kan t.ex, försök igen efter 2 sekunder sedan 4 sekunder sedan 10 sekunder sedan 30 sekunder och ge helt.</span><span class="sxs-lookup"><span data-stu-id="dcc54-408">For example, your application may retry after 2 seconds, then 4 seconds, then 10 seconds, then 30 seconds, and then give up completely.</span></span> <span data-ttu-id="dcc54-409">Detta resulterar i ditt program avsevärt minska belastningen på tjänsten i stället exacerbating eventuella problem.</span><span class="sxs-lookup"><span data-stu-id="dcc54-409">This behavior results in your application significantly reducing its load on the service rather than exacerbating any problems.</span></span>  

<span data-ttu-id="dcc54-410">Observera att anslutningsfel kan göras omedelbart, eftersom de inte är resultatet av begränsning och förväntas vara tillfälligt.</span><span class="sxs-lookup"><span data-stu-id="dcc54-410">Note that connectivity errors can be retried immediately, because they are not the result of throttling and are expected to be transient.</span></span>  

#### <span data-ttu-id="dcc54-411"><a name="subheading15"></a>Icke-Återförsökbart fel</span><span class="sxs-lookup"><span data-stu-id="dcc54-411"><a name="subheading15"></a>Non-Retryable Errors</span></span>
<span data-ttu-id="dcc54-412">Klientbiblioteken är medveten om vilka fel kan retry och som inte är.</span><span class="sxs-lookup"><span data-stu-id="dcc54-412">The client libraries are aware of which errors are retry-able and which are not.</span></span> <span data-ttu-id="dcc54-413">Tänk dock på om du skriver egen kod mot storage REST-API, det finns några fel som du inte bör försöka: till exempel en 400 (felaktig begäran) svaret anger att klientprogrammet har skickat en begäran inte kunde bearbetas eftersom det inte var ett förväntat format.</span><span class="sxs-lookup"><span data-stu-id="dcc54-413">However, if you are writing your own code against the storage REST API, remember there are some errors that you should not retry: for example, a 400 (Bad Request) response indicates that the client application sent a request that could not be processed because it was not in an expected form.</span></span> <span data-ttu-id="dcc54-414">Skicka om begäran resulterar samma svar varje gång, så det finns ingen anledning du försöker den.</span><span class="sxs-lookup"><span data-stu-id="dcc54-414">Resending this request will result the same response every time, so there is no point in retrying it.</span></span> <span data-ttu-id="dcc54-415">Om du skriver egen kod mot storage REST API vara medveten om vad de betyder och på rätt sätt att försöka igen (eller inte) för var och en av dem.</span><span class="sxs-lookup"><span data-stu-id="dcc54-415">If you are writing your own code against the storage REST API, be aware of what the error codes mean and the proper way to retry (or not) for each of them.</span></span>  

#### <a name="useful-resources"></a><span data-ttu-id="dcc54-416">Användbara resurser</span><span class="sxs-lookup"><span data-stu-id="dcc54-416">Useful Resources</span></span>
<span data-ttu-id="dcc54-417">Mer information om lagring felkoder finns [Status och felkoder](http://msdn.microsoft.com/library/azure/dd179382.aspx) på webbplatsen Microsoft Azure.</span><span class="sxs-lookup"><span data-stu-id="dcc54-417">For more information about storage error codes, see [Status and Error Codes](http://msdn.microsoft.com/library/azure/dd179382.aspx) on the Microsoft Azure web site.</span></span>  

## <a name="blobs"></a><span data-ttu-id="dcc54-418">Blobar</span><span class="sxs-lookup"><span data-stu-id="dcc54-418">Blobs</span></span>
<span data-ttu-id="dcc54-419">Förutom beprövade metoder för [alla tjänster](#allservices) som beskrivs ovan, följande beprövade metoder som gäller specifikt för blob-tjänsten.</span><span class="sxs-lookup"><span data-stu-id="dcc54-419">In addition to the proven practices for [All Services](#allservices) described previously, the following proven practices apply specifically to the blob service.</span></span>  

### <a name="blob-specific-scalability-targets"></a><span data-ttu-id="dcc54-420">BLOB-specifika skalbarhetsmål</span><span class="sxs-lookup"><span data-stu-id="dcc54-420">Blob-Specific Scalability Targets</span></span>
#### <span data-ttu-id="dcc54-421"><a name="subheading46"></a>Flera klienter som ansluter till ett enda objekt samtidigt</span><span class="sxs-lookup"><span data-stu-id="dcc54-421"><a name="subheading46"></a>Multiple clients accessing a single object concurrently</span></span>
<span data-ttu-id="dcc54-422">Om du har ett stort antal klienter som ansluter till ett enda objekt samtidigt behöver du överväga per objekt och lagring skalbarhetsmål för lagringskontot.</span><span class="sxs-lookup"><span data-stu-id="dcc54-422">If you have a large number of clients accessing a single object concurrently you will need to consider per object and storage account scalability targets.</span></span> <span data-ttu-id="dcc54-423">Det exakta antalet klienter som kan komma åt ett objekt ska variera beroende på faktorer som hur många klienter som begär objektet samtidigt, storleken på objektet, nätverk villkor osv.</span><span class="sxs-lookup"><span data-stu-id="dcc54-423">The exact number of clients that can access a single object will vary depending on factors such as the number of clients requesting the object simultaneously, the size of the object, network conditions etc.</span></span>

<span data-ttu-id="dcc54-424">Om objektet kan distribueras via en CDN, till exempel bilder eller videofiler hanteras från en webbplats och du bör använda en CDN.</span><span class="sxs-lookup"><span data-stu-id="dcc54-424">If the object can be distributed through a CDN such as images or videos served from a website then you should use a CDN.</span></span> <span data-ttu-id="dcc54-425">Se [här](#subheading5).</span><span class="sxs-lookup"><span data-stu-id="dcc54-425">See [here](#subheading5).</span></span>

<span data-ttu-id="dcc54-426">I andra scenarier, till exempel vetenskapliga simulering där data är konfidentiellt har du två alternativ.</span><span class="sxs-lookup"><span data-stu-id="dcc54-426">In other scenarios such as scientific simulations where the data is confidential you have two options.</span></span> <span data-ttu-id="dcc54-427">Först är att sprida ut din arbetsbelastning åtkomst så att komma åt objektet under en period om jämfört används samtidigt.</span><span class="sxs-lookup"><span data-stu-id="dcc54-427">The first is to stagger your workload's access such that the object is accessed over a period of time vs being accessed simultaneously.</span></span> <span data-ttu-id="dcc54-428">Du kan också kopiera objektet tillfälligt till flera storage-konton, vilket ökar den totala IOPS per objekt och över storage-konton.</span><span class="sxs-lookup"><span data-stu-id="dcc54-428">Alternatively, you can temporarily copy the object to multiple storage accounts thus increasing the total IOPS per object and across storage accounts.</span></span> <span data-ttu-id="dcc54-429">Begränsad testning påträffades att cirka 25 virtuella datorer kan hämta en 100GB blob parallellt (varje virtuell dator parallelizing nedladdningen med 32 trådar) samtidigt.</span><span class="sxs-lookup"><span data-stu-id="dcc54-429">In limited testing we found that around 25 VMs could simultaneously download a 100GB blob in parallel (each VM was parallelizing the download using 32 threads).</span></span> <span data-ttu-id="dcc54-430">Om du har 100 klienter behöver komma åt objektet, först kopiera den till en andra storage-konto och har de första 50 virtuella datorer åtkomst till den första blobben och andra 50 virtuella datorer åtkomst till andra blob.</span><span class="sxs-lookup"><span data-stu-id="dcc54-430">If you had 100 clients needing to access the object, first copy it to a second storage account and then have the first 50 VMs access the first blob and the second 50 VMs access the second blob.</span></span> <span data-ttu-id="dcc54-431">Resultatet varierar beroende på din program-beteende så bör du testa under design.</span><span class="sxs-lookup"><span data-stu-id="dcc54-431">Results will vary depending on your applications behavior so you should test this during design.</span></span> 

#### <span data-ttu-id="dcc54-432"><a name="subheading16"></a>Bandbredd och -åtgärder per Blob</span><span class="sxs-lookup"><span data-stu-id="dcc54-432"><a name="subheading16"></a>Bandwidth and operations per Blob</span></span>
<span data-ttu-id="dcc54-433">Du kan läsa eller skriva till en enda blob på högst 60 MB per sekund (detta är ungefär 480 Mbit/s som överskrider kapaciteterna för flera nätverk för klient på klientsidan (inklusive det fysiska nätverkskortet på klientenheten).</span><span class="sxs-lookup"><span data-stu-id="dcc54-433">You can read or write to a single blob at up to a maximum of 60 MB/second (this is approximately 480 Mbps which exceeds the capabilities of many client side networks (including the physical NIC on the client device).</span></span> <span data-ttu-id="dcc54-434">Dessutom kan stöder en enda blob upp till 500 begäranden per sekund.</span><span class="sxs-lookup"><span data-stu-id="dcc54-434">In addition, a single blob supports up to 500 requests per second.</span></span> <span data-ttu-id="dcc54-435">Om du har flera klienter som behöver läsa samma blob och du kanske överskrider gränserna, bör du använda en CDN för att distribuera blob.</span><span class="sxs-lookup"><span data-stu-id="dcc54-435">If you have multiple clients that need to read the same blob and you might exceed these limits, you should consider using a CDN for distributing the blob.</span></span>  

<span data-ttu-id="dcc54-436">Mer information om mål-genomströmning för BLOB finns [Azure Storage skalbarhets- och prestandamål](storage-scalability-targets.md).</span><span class="sxs-lookup"><span data-stu-id="dcc54-436">For more information about target throughput for blobs, see [Azure Storage Scalability and Performance Targets](storage-scalability-targets.md).</span></span>  

### <a name="copying-and-moving-blobs"></a><span data-ttu-id="dcc54-437">Kopiera och flytta Blobbar</span><span class="sxs-lookup"><span data-stu-id="dcc54-437">Copying and Moving Blobs</span></span>
#### <span data-ttu-id="dcc54-438"><a name="subheading17"></a>Kopiera Blob</span><span class="sxs-lookup"><span data-stu-id="dcc54-438"><a name="subheading17"></a>Copy Blob</span></span>
<span data-ttu-id="dcc54-439">Storage REST API version 2012-02-12 införs användbar möjligheten att kopiera BLOB mellan konton: ett klientprogram kan instruera lagringstjänsten att kopiera en blobb från en annan källa (eventuellt i ett annat lagringskonto) och därefter låta tjänsten kopiera asynkront.</span><span class="sxs-lookup"><span data-stu-id="dcc54-439">The storage REST API version 2012-02-12 introduced the useful ability to copy blobs across accounts: a client application can instruct the storage service to copy a blob from another source (possibly in a different storage account), and then let the service perform the copy asynchronously.</span></span> <span data-ttu-id="dcc54-440">Detta kan avsevärt minska den bandbredd som krävs för programmet när du migrerar data från andra lagringskonton eftersom du inte behöver hämta och överföra data.</span><span class="sxs-lookup"><span data-stu-id="dcc54-440">This can significantly reduce the bandwidth needed for the application when you are migrating data from other storage accounts because you do not need to download and upload the data.</span></span>  

<span data-ttu-id="dcc54-441">En fråga, men är att, när du kopierar mellan lagringskonton finns det ingen garanti för tid för när kopieringen slutförs.</span><span class="sxs-lookup"><span data-stu-id="dcc54-441">One consideration, however, is that, when copying between storage accounts, there is no time guarantee on when the copy will complete.</span></span> <span data-ttu-id="dcc54-442">Om ditt program behöver slutföra en blob-kopia snabbt under din kontroll, kan det vara bättre att kopiera blob genom att hämta den till en virtuell dator och överföra den till målet.</span><span class="sxs-lookup"><span data-stu-id="dcc54-442">If your application needs to complete a blob copy quickly under your control, it may be better to copy the blob by downloading it to a VM and then uploading it to the destination.</span></span>  <span data-ttu-id="dcc54-443">Se till att kopian utförs av en virtuell dator som körs i samma Azure-region, annars nätverksförhållanden kan (och troligtvis kommer) påverkar prestandan kopia för fullständig förutsägbarhet i så fall.</span><span class="sxs-lookup"><span data-stu-id="dcc54-443">For full predictability in that situation, ensure that the copy is performed by a VM running in the same Azure region, or else network conditions may (and probably will) affect your copy performance.</span></span>  <span data-ttu-id="dcc54-444">Dessutom kan du övervaka förloppet för en asynkron kopia programmässigt.</span><span class="sxs-lookup"><span data-stu-id="dcc54-444">In addition, you can monitor the progress of an asynchronous copy programmatically.</span></span>  

<span data-ttu-id="dcc54-445">Observera att kopior inom samma lagringskonto själva är vanligtvis slutförda snabbt.</span><span class="sxs-lookup"><span data-stu-id="dcc54-445">Note that copies within the same storage account itself are generally completed quickly.</span></span>  

<span data-ttu-id="dcc54-446">Mer information finns i [kopiera Blob](http://msdn.microsoft.com/library/azure/dd894037.aspx).</span><span class="sxs-lookup"><span data-stu-id="dcc54-446">For more information, see [Copy Blob](http://msdn.microsoft.com/library/azure/dd894037.aspx).</span></span>  

#### <span data-ttu-id="dcc54-447"><a name="subheading18"></a>Använda AzCopy</span><span class="sxs-lookup"><span data-stu-id="dcc54-447"><a name="subheading18"></a>Use AzCopy</span></span>
<span data-ttu-id="dcc54-448">Azure Storage-teamet har publicerat ett kommandoradsverktyg ”AzCopy” som är tänkt att hjälpa med bulk överför många BLOB till, från och mellan lagringskonton.</span><span class="sxs-lookup"><span data-stu-id="dcc54-448">The Azure Storage team has released a command-line tool "AzCopy" that is meant to help with bulk transferring many blobs to, from, and across storage accounts.</span></span>  <span data-ttu-id="dcc54-449">Det här verktyget är optimerad för det här scenariot och uppnå hög överföringshastighet.</span><span class="sxs-lookup"><span data-stu-id="dcc54-449">This tool is optimized for this scenario, and can achieve high transfer rates.</span></span>  <span data-ttu-id="dcc54-450">Används rekommenderas för bulk-överföringen, hämtning och kopiera scenarier.</span><span class="sxs-lookup"><span data-stu-id="dcc54-450">Its use is encouraged for bulk upload, download, and copy scenarios.</span></span> <span data-ttu-id="dcc54-451">Om du vill veta mer om den och ladda ned den finns [överföra data med kommandoradsverktyget Azcopy](storage-use-azcopy.md).</span><span class="sxs-lookup"><span data-stu-id="dcc54-451">To learn more about it and download it, see [Transfer data with the AzCopy Command-Line Utility](storage-use-azcopy.md).</span></span>  

#### <span data-ttu-id="dcc54-452"><a name="subheading19"></a>Tjänsten Azure Import/Export</span><span class="sxs-lookup"><span data-stu-id="dcc54-452"><a name="subheading19"></a>Azure Import/Export Service</span></span>
<span data-ttu-id="dcc54-453">För mycket stora mängder data (mer än 1TB) erbjuder Azure Storage Import/Export-tjänsten, som gör det möjligt att överföra och ladda ned från blob storage med leverans hårddiskar.</span><span class="sxs-lookup"><span data-stu-id="dcc54-453">For very large volumes of data (more than 1TB), the Azure Storage offers the Import/Export service, which allows for uploading and downloading from blob storage by shipping hard drives.</span></span>  <span data-ttu-id="dcc54-454">Du kan publicera dina data på en hårddisk och skickar informationen till Microsoft för överföring eller skicka en tom hårddisk till Microsoft för att hämta data.</span><span class="sxs-lookup"><span data-stu-id="dcc54-454">You can put your data on a hard drive and send it to Microsoft for upload, or send a blank hard drive to Microsoft to download data.</span></span>  <span data-ttu-id="dcc54-455">Mer information finns i [använda tjänsten Microsoft Azure Import/Export för att överföra Data till Blob Storage](../storage-import-export-service.md).</span><span class="sxs-lookup"><span data-stu-id="dcc54-455">For more information, see [Use the Microsoft Azure Import/Export Service to Transfer Data to Blob Storage](../storage-import-export-service.md).</span></span>  <span data-ttu-id="dcc54-456">Det kan vara mycket effektivare än att överföra/hämta volymen av data över nätverket.</span><span class="sxs-lookup"><span data-stu-id="dcc54-456">This can be much more efficient than uploading/downloading this volume of data over the network.</span></span>  

### <span data-ttu-id="dcc54-457"><a name="subheading20"></a>Använda metadata</span><span class="sxs-lookup"><span data-stu-id="dcc54-457"><a name="subheading20"></a>Use metadata</span></span>
<span data-ttu-id="dcc54-458">Blob-tjänsten stöder head-begäranden som kan innehålla metadata om blob.</span><span class="sxs-lookup"><span data-stu-id="dcc54-458">The blob service supports head requests, which can include metadata about the blob.</span></span> <span data-ttu-id="dcc54-459">Om ditt program behövs EXIF-data från ett foto, kan den hämta bilden och extrahera det.</span><span class="sxs-lookup"><span data-stu-id="dcc54-459">For example, if your application needed the EXIF data out of a photo, it could retrieve the photo and extract it.</span></span> <span data-ttu-id="dcc54-460">För att spara bandbredd och förbättra prestanda, kan ditt program lagra data EXIF i blobens metadata när programmet har överförts bilden: du kan hämta EXIF-data i metadata med hjälp av endast en HEAD-begäran, spara betydande bandbredd och tid som behövs för att extrahera EXIF data varje gång blob läses.</span><span class="sxs-lookup"><span data-stu-id="dcc54-460">To save bandwidth and improve performance, your application could store the EXIF data in the blob's metadata when the application uploaded the photo: you can then retrieve the EXIF data in metadata using only a HEAD request, saving significant bandwidth and the processing time needed to extract the EXIF data each time the blob is read.</span></span> <span data-ttu-id="dcc54-461">Detta kan vara användbart i scenarier där du behöver bara metadata och inte det fullständiga innehållet på en blob.</span><span class="sxs-lookup"><span data-stu-id="dcc54-461">This would be useful in scenarios where you only need the metadata, and not the full content of a blob.</span></span>  <span data-ttu-id="dcc54-462">Observera att endast 8 KB metadata kan lagras per blob (tjänsten inte accepterar en begäran om att lagra större än), så om data inte ryms i den storleken, kan du inte kunna använda den här metoden.</span><span class="sxs-lookup"><span data-stu-id="dcc54-462">Note that only 8 KB of metadata can be stored per blob (the service will not accept a request to store more than that), so if the data does not fit in that size, you may not be able to use this approach.</span></span>  

<span data-ttu-id="dcc54-463">Ett exempel på hur du hämtar en blob-metadata med hjälp av .NET finns [Set och hämta egenskaper och Metadata](../blobs/storage-properties-metadata.md).</span><span class="sxs-lookup"><span data-stu-id="dcc54-463">For an example of how to get a blob's metadata using .NET, see [Set and Retrieve Properties and Metadata](../blobs/storage-properties-metadata.md).</span></span>  

### <a name="uploading-fast"></a><span data-ttu-id="dcc54-464">Snabb överföring</span><span class="sxs-lookup"><span data-stu-id="dcc54-464">Uploading Fast</span></span>
<span data-ttu-id="dcc54-465">Om du vill överföra blobbar snabb, är den första frågan besvaras: är du överföra en blob eller många?</span><span class="sxs-lookup"><span data-stu-id="dcc54-465">To upload blobs fast, the first question to answer is: are you uploading one blob or many?</span></span>  <span data-ttu-id="dcc54-466">Använd den nedan för att avgöra vilken metod som har rätt att använda beroende på ditt scenario.</span><span class="sxs-lookup"><span data-stu-id="dcc54-466">Use the below guidance to determine the correct method to use depending on your scenario.</span></span>  

#### <span data-ttu-id="dcc54-467"><a name="subheading21"></a>Ladda upp en stor blob snabbt</span><span class="sxs-lookup"><span data-stu-id="dcc54-467"><a name="subheading21"></a>Uploading one large blob quickly</span></span>
<span data-ttu-id="dcc54-468">Om du vill överföra en enda stor blob snabbt klientprogrammet ladda upp dess block eller sidor parallellt (är uppmärksam på skalbarhetsmål för enskilda blobbar och lagringskontot som helhet).</span><span class="sxs-lookup"><span data-stu-id="dcc54-468">To upload a single large blob quickly, your client application should upload its blocks or pages in parallel (being mindful of the scalability targets for individual blobs and the storage account as a whole).</span></span>  <span data-ttu-id="dcc54-469">Observera att de officiella Microsoft RTM lagring klientbibliotek (.NET, Java) ha möjlighet att göra detta.</span><span class="sxs-lookup"><span data-stu-id="dcc54-469">Note that the official Microsoft-provided RTM Storage Client libraries (.NET, Java) have the ability to do this.</span></span>  <span data-ttu-id="dcc54-470">För varje bibliotek använder den under angivna objektegenskaper att ställa in samtidighet:</span><span class="sxs-lookup"><span data-stu-id="dcc54-470">For each of the libraries, use the below specified object/property to set the level of concurrency:</span></span>  

* <span data-ttu-id="dcc54-471">.NET: Ange ParallelOperationThreadCount på ett BlobRequestOptions-objekt som ska användas.</span><span class="sxs-lookup"><span data-stu-id="dcc54-471">.NET: Set ParallelOperationThreadCount on a BlobRequestOptions object to be used.</span></span>
* <span data-ttu-id="dcc54-472">Java/Android: Använda BlobRequestOptions.setConcurrentRequestCount()</span><span class="sxs-lookup"><span data-stu-id="dcc54-472">Java/Android: Use BlobRequestOptions.setConcurrentRequestCount()</span></span>
* <span data-ttu-id="dcc54-473">Node.js: Använd parallelOperationThreadCount alternativen begäran eller blob-tjänsten.</span><span class="sxs-lookup"><span data-stu-id="dcc54-473">Node.js: Use parallelOperationThreadCount on either the request options or on the blob service.</span></span>
* <span data-ttu-id="dcc54-474">C++: Använda metoden blob_request_options::set_parallelism_factor.</span><span class="sxs-lookup"><span data-stu-id="dcc54-474">C++: Use the blob_request_options::set_parallelism_factor method.</span></span>

#### <span data-ttu-id="dcc54-475"><a name="subheading22"></a>Överför många blobbar snabbt</span><span class="sxs-lookup"><span data-stu-id="dcc54-475"><a name="subheading22"></a>Uploading many blobs quickly</span></span>
<span data-ttu-id="dcc54-476">Om du vill överföra många blobbar snabbt överföra blobbar parallellt.</span><span class="sxs-lookup"><span data-stu-id="dcc54-476">To upload many blobs quickly, upload blobs in parallel.</span></span> <span data-ttu-id="dcc54-477">Det här är snabbare än att överföra enda blobbar i taget med parallellt block överföringar eftersom det sprids överföringen över flera partitioner för lagringstjänsten.</span><span class="sxs-lookup"><span data-stu-id="dcc54-477">This is faster than uploading single blobs at a time with parallel block uploads because it spreads the upload across multiple partitions of the storage service.</span></span> <span data-ttu-id="dcc54-478">En enda blob stöder bara en genomströmning på 60 MB per sekund (cirka 480 Mbit/s).</span><span class="sxs-lookup"><span data-stu-id="dcc54-478">A single blob only supports a throughput of 60 MB/second (approximately 480 Mbps).</span></span> <span data-ttu-id="dcc54-479">Ett konto i USA-baserade LRS stöder upp till 20 Gbit/s-ingång som är större än dataflöde som stöds av en enskild blob vid tidpunkten för skrivning.</span><span class="sxs-lookup"><span data-stu-id="dcc54-479">At the time of writing, a US-based LRS account supports up to 20 Gbps ingress which is far more than the throughput supported by an individual blob.</span></span>  <span data-ttu-id="dcc54-480">[AzCopy](#subheading18) utför överföringar parallellt som standard och rekommenderas för det här scenariot.</span><span class="sxs-lookup"><span data-stu-id="dcc54-480">[AzCopy](#subheading18) performs uploads in parallel by default, and is recommended for this scenario.</span></span>  

### <span data-ttu-id="dcc54-481"><a name="subheading23"></a>Att välja rätt typ av blob</span><span class="sxs-lookup"><span data-stu-id="dcc54-481"><a name="subheading23"></a>Choosing the correct type of blob</span></span>
<span data-ttu-id="dcc54-482">Azure Storage stöder två typer av blob: *sidan* blobbar och *block* blobbar.</span><span class="sxs-lookup"><span data-stu-id="dcc54-482">Azure Storage supports two types of blob: *page* blobs and *block* blobs.</span></span> <span data-ttu-id="dcc54-483">För en given användningsscenariot påverkar valet av blobbtypen prestanda och skalbarhet i lösningen.</span><span class="sxs-lookup"><span data-stu-id="dcc54-483">For a given usage scenario, your choice of blob type will affect the performance and scalability of your solution.</span></span> <span data-ttu-id="dcc54-484">Blockblobbar är lämplig när du vill överföra stora mängder data effektivt: till exempel ett klientprogram kan behöva ladda upp bilder eller video till blob storage.</span><span class="sxs-lookup"><span data-stu-id="dcc54-484">Block blobs are appropriate when you want to upload large amounts of data efficiently: for example, a client application may need to upload photos or video to blob storage.</span></span> <span data-ttu-id="dcc54-485">Sidblobbar är lämpliga om programmet behöver utföra slumpmässiga skrivningar på data: till exempel Azure virtuella hårddiskarna lagras som sidblobar.</span><span class="sxs-lookup"><span data-stu-id="dcc54-485">Page blobs are appropriate if the application needs to perform random writes on the data: for example, Azure VHDs are stored as page blobs.</span></span>  

<span data-ttu-id="dcc54-486">Mer information finns i [förstå Blockblobbar, Tilläggsblobbar och Sidblobbar](http://msdn.microsoft.com/library/azure/ee691964.aspx).</span><span class="sxs-lookup"><span data-stu-id="dcc54-486">For more information, see [Understanding Block Blobs, Append Blobs, and Page Blobs](http://msdn.microsoft.com/library/azure/ee691964.aspx).</span></span>  

## <a name="tables"></a><span data-ttu-id="dcc54-487">Tabeller</span><span class="sxs-lookup"><span data-stu-id="dcc54-487">Tables</span></span>
<span data-ttu-id="dcc54-488">Förutom beprövade metoder för [alla tjänster](#allservices) som beskrivs ovan, följande beprövade metoder gäller särskilt för tabelltjänsten.</span><span class="sxs-lookup"><span data-stu-id="dcc54-488">In addition to the proven practices for [All Services](#allservices) described previously, the following proven practices apply specifically to the table service.</span></span>  

### <span data-ttu-id="dcc54-489"><a name="subheading24"></a>Tabell-specifika skalbarhetsmål</span><span class="sxs-lookup"><span data-stu-id="dcc54-489"><a name="subheading24"></a>Table-Specific Scalability Targets</span></span>
<span data-ttu-id="dcc54-490">Utöver bandbreddsbegränsningar för en hel lagringskonto har tabeller följande specifika skalbarhetsgränsen.</span><span class="sxs-lookup"><span data-stu-id="dcc54-490">In addition to the bandwidth limitations of an entire storage account, tables have the following specific scalability limit.</span></span>  <span data-ttu-id="dcc54-491">Observera att systemet ska belastningsutjämna som ökar din trafik, men om trafiken har plötslig belastning kan du kanske inte går att hämta den här volymen genomströmning omedelbart.</span><span class="sxs-lookup"><span data-stu-id="dcc54-491">Note that the system will load balance as your traffic increases, but if your traffic has sudden bursts, you may not be able to get this volume of throughput immediately.</span></span>  <span data-ttu-id="dcc54-492">Om mönstret har belastning, bör du förväntar dig att se begränsning och tidsgränser under burst som lagring tjänsten automatiskt belastningen saldon i tabellen.</span><span class="sxs-lookup"><span data-stu-id="dcc54-492">If your pattern has bursts, you should expect to see throttling and/or timeouts during the burst as the storage service automatically load balances out your table.</span></span>  <span data-ttu-id="dcc54-493">Långsamt vanligtvis av dig har bättre resultat som den ger systemtiden att belastningsutjämna på lämpligt sätt.</span><span class="sxs-lookup"><span data-stu-id="dcc54-493">Ramping up slowly generally has better results as it gives the system time to load balance appropriately.</span></span>  

#### <a name="entities-per-second-account"></a><span data-ttu-id="dcc54-494">Entiteter per sekund (konto)</span><span class="sxs-lookup"><span data-stu-id="dcc54-494">Entities per Second (Account)</span></span>
<span data-ttu-id="dcc54-495">Skalbarhetsgränsen för att komma åt tabeller är upp till 20 000 enheter (1KB som är varje) per sekund för ett konto.</span><span class="sxs-lookup"><span data-stu-id="dcc54-495">The scalability limit for accessing tables is up to 20,000 entities (1KB each) per second for an account.</span></span>  <span data-ttu-id="dcc54-496">I allmänhet varje entitet som infogas, uppdateras, tas bort eller genomsöks antal mot det här målet.</span><span class="sxs-lookup"><span data-stu-id="dcc54-496">In general, each entity that is inserted, updated, deleted, or scanned counts toward this target.</span></span>  <span data-ttu-id="dcc54-497">Infoga en batch som innehåller 100 entiteter skulle så räknas som 100 entiteter.</span><span class="sxs-lookup"><span data-stu-id="dcc54-497">So a batch insert that contains 100 entities would count as 100 entities.</span></span>  <span data-ttu-id="dcc54-498">En fråga som genomsöker 1000 entiteter och returnerar 5 räknas som 1000 enheter.</span><span class="sxs-lookup"><span data-stu-id="dcc54-498">A query that scans 1000 entities and returns 5 would count as 1000 entities.</span></span>  

#### <a name="entities-per-second-partition"></a><span data-ttu-id="dcc54-499">Entiteter per sekund (Partition)</span><span class="sxs-lookup"><span data-stu-id="dcc54-499">Entities per Second (Partition)</span></span>
<span data-ttu-id="dcc54-500">Inom en enskild partition är skalbarhet målet för att komma åt tabeller 2 000 enheter (1KB som är varje) per sekund, med samma inventering som beskrivs i föregående avsnitt.</span><span class="sxs-lookup"><span data-stu-id="dcc54-500">Within a single partition, the scalability target for accessing tables is 2,000 entities (1KB each) per second, using the same counting as described in the previous section.</span></span>  

### <a name="configuration"></a><span data-ttu-id="dcc54-501">Konfiguration</span><span class="sxs-lookup"><span data-stu-id="dcc54-501">Configuration</span></span>
<span data-ttu-id="dcc54-502">Det här avsnittet innehåller flera snabb konfigurationsinställningar som du kan använda för att göra betydande prestandaförbättringar i tabelltjänsten:</span><span class="sxs-lookup"><span data-stu-id="dcc54-502">This section lists several quick configuration settings that you can use to make significant performance improvements in the table service:</span></span>  

#### <span data-ttu-id="dcc54-503"><a name="subheading25"></a>Använd JSON</span><span class="sxs-lookup"><span data-stu-id="dcc54-503"><a name="subheading25"></a>Use JSON</span></span>
<span data-ttu-id="dcc54-504">Från och med version av storage service 2013-08-15, stöder tabelltjänsten användningen av JSON i stället för XML-baserade AtomPub-format för att överföra tabelldata.</span><span class="sxs-lookup"><span data-stu-id="dcc54-504">Beginning with storage service version 2013-08-15, the table service supports using JSON instead of the XML-based AtomPub format for transferring table data.</span></span> <span data-ttu-id="dcc54-505">Detta kan minska nyttolast storlekar som 75% och förbättrar prestandan för din app.</span><span class="sxs-lookup"><span data-stu-id="dcc54-505">This can reduce payload sizes by as much as 75% and can significantly improve the performance of your application.</span></span>

<span data-ttu-id="dcc54-506">Mer information finns i inlägg [Microsoft Azure-tabeller: introduktion till JSON](http://blogs.msdn.com/b/windowsazurestorage/archive/2013/12/05/windows-azure-tables-introducing-json.aspx) och [Nyttolastformat för tabellen tjänståtgärder](http://msdn.microsoft.com/library/azure/dn535600.aspx).</span><span class="sxs-lookup"><span data-stu-id="dcc54-506">For more information, see the post [Microsoft Azure Tables: Introducing JSON](http://blogs.msdn.com/b/windowsazurestorage/archive/2013/12/05/windows-azure-tables-introducing-json.aspx) and [Payload Format for Table Service Operations](http://msdn.microsoft.com/library/azure/dn535600.aspx).</span></span>

#### <span data-ttu-id="dcc54-507"><a name="subheading26"></a>Nagle ut</span><span class="sxs-lookup"><span data-stu-id="dcc54-507"><a name="subheading26"></a>Nagle Off</span></span>
<span data-ttu-id="dcc54-508">Nagles algoritmen implementeras över TCP/IP-nätverk som används för att förbättra nätverksprestanda.</span><span class="sxs-lookup"><span data-stu-id="dcc54-508">Nagle's algorithm is widely implemented across TCP/IP networks as a means to improve network performance.</span></span> <span data-ttu-id="dcc54-509">Det är dock inte optimalt i samtliga fall (till exempel interaktiva miljöer).</span><span class="sxs-lookup"><span data-stu-id="dcc54-509">However, it is not optimal in all circumstances (such as highly interactive environments).</span></span> <span data-ttu-id="dcc54-510">Nagles algoritm har en negativ inverkan på prestanda för begäranden till tjänsterna tabell och kön för Azure Storage, och bör du inaktivera den om möjligt.</span><span class="sxs-lookup"><span data-stu-id="dcc54-510">For Azure Storage, Nagle's algorithm has a negative impact on the performance of requests to the table and queue services, and you should disable it if possible.</span></span>  

<span data-ttu-id="dcc54-511">Mer information finns i vår blogginlägget [Nagles algoritmen är inte egna gentemot små begäran](http://blogs.msdn.com/b/windowsazurestorage/archive/2010/06/25/nagle-s-algorithm-is-not-friendly-towards-small-requests.aspx), som förklarar varför Nagles algoritmen dåligt samverkar med tabell- och köegenskaper begäranden och visar hur du inaktiverar det i ditt klientprogram.</span><span class="sxs-lookup"><span data-stu-id="dcc54-511">For more information, see our blog post [Nagle's Algorithm is Not Friendly towards Small Requests](http://blogs.msdn.com/b/windowsazurestorage/archive/2010/06/25/nagle-s-algorithm-is-not-friendly-towards-small-requests.aspx), which explains why Nagle's algorithm interacts poorly with table and queue requests, and shows how to disable it in your client application.</span></span>  

### <a name="schema"></a><span data-ttu-id="dcc54-512">Schemat</span><span class="sxs-lookup"><span data-stu-id="dcc54-512">Schema</span></span>
<span data-ttu-id="dcc54-513">Hur du representera och fråga data är den största en faktor som påverkar prestanda för tabelltjänsten.</span><span class="sxs-lookup"><span data-stu-id="dcc54-513">How you represent and query your data is the biggest single factor that affects the performance of the table service.</span></span> <span data-ttu-id="dcc54-514">Varje program är olika, beskrivs i det här avsnittet några allmänna beprövade metoder som relaterar till:</span><span class="sxs-lookup"><span data-stu-id="dcc54-514">While every application is different, this section outlines some general proven practices that relate to:</span></span>  

* <span data-ttu-id="dcc54-515">Tabelldesign</span><span class="sxs-lookup"><span data-stu-id="dcc54-515">Table design</span></span>
* <span data-ttu-id="dcc54-516">Effektiva frågor</span><span class="sxs-lookup"><span data-stu-id="dcc54-516">Efficient queries</span></span>
* <span data-ttu-id="dcc54-517">Effektiv uppdateringar</span><span class="sxs-lookup"><span data-stu-id="dcc54-517">Efficient data updates</span></span>  

#### <span data-ttu-id="dcc54-518"><a name="subheading27"></a>Tabeller och partitioner</span><span class="sxs-lookup"><span data-stu-id="dcc54-518"><a name="subheading27"></a>Tables and partitions</span></span>
<span data-ttu-id="dcc54-519">Tabeller är indelade i partitioner.</span><span class="sxs-lookup"><span data-stu-id="dcc54-519">Tables are divided into partitions.</span></span> <span data-ttu-id="dcc54-520">Varje enhet som lagras i en partition delar samma partitionsnyckel och har en unik rad för att identifiera den i den aktuella partitionen.</span><span class="sxs-lookup"><span data-stu-id="dcc54-520">Every entity stored in a partition shares the same partition key and has a unique row key to identify it within that partition.</span></span> <span data-ttu-id="dcc54-521">Partitioner ger fördelar, men också introducera skalbarhetsbegränsningar.</span><span class="sxs-lookup"><span data-stu-id="dcc54-521">Partitions provide benefits but also introduce scalability limits.</span></span>  

* <span data-ttu-id="dcc54-522">Fördelar: Du kan uppdatera entiteter i samma partition i en enskild-atomic, batch-transaktion som innehåller upp till 100 separat lagringsåtgärder (högst 4MB, total storlek).</span><span class="sxs-lookup"><span data-stu-id="dcc54-522">Benefits: You can update entities in the same partition in a single, atomic, batch transaction that contains up to 100 separate storage operations (limit of 4MB total size).</span></span> <span data-ttu-id="dcc54-523">Under förutsättning att samma antal enheter som ska hämtas, kan du också fråga data i en enda partition effektivare än data sträcker sig över flera partitioner (även om läsa på ytterligare rekommendationer för frågar tabelldata).</span><span class="sxs-lookup"><span data-stu-id="dcc54-523">Assuming the same number of entities to be retrieved, you can also query data within a single partition more efficiently than data that spans partitions (though read on for further recommendations on querying table data).</span></span>
* <span data-ttu-id="dcc54-524">Skalbarhetsgränsen: åtkomst till entiteter som lagras i en partition kan inte vara belastningsutjämnad eftersom partitioner stöder atomiska Batchtransaktioner.</span><span class="sxs-lookup"><span data-stu-id="dcc54-524">Scalability limit: Access to entities stored in a single partition cannot be load-balanced because partitions support atomic batch transactions.</span></span> <span data-ttu-id="dcc54-525">Därför är skalbarhet mål för en enskild tabell partition lägre än för tabelltjänsten som helhet.</span><span class="sxs-lookup"><span data-stu-id="dcc54-525">For this reason, the scalability target for an individual table partition is lower than for the table service as a whole.</span></span>  

<span data-ttu-id="dcc54-526">På grund av dessa tabeller och egenskaper partitioner, bör du vidta följande designprinciperna:</span><span class="sxs-lookup"><span data-stu-id="dcc54-526">Because of these characteristics of tables and partitions, you should adopt the following design principles:</span></span>  

* <span data-ttu-id="dcc54-527">Data som ditt klientprogram uppdateras ofta eller frågas i samma logiska arbetsenheten måste finnas i samma partition.</span><span class="sxs-lookup"><span data-stu-id="dcc54-527">Data that your client application frequently updated or queried in the same logical unit of work should be located in the same partition.</span></span>  <span data-ttu-id="dcc54-528">Det kan vara eftersom programmet är sammanställa skrivningar eller eftersom du vill dra nytta av atomiska batchåtgärder.</span><span class="sxs-lookup"><span data-stu-id="dcc54-528">This may be because your application is aggregating writes, or because you want to take advantage of atomic batch operations.</span></span>  <span data-ttu-id="dcc54-529">Dessutom kan data i en partition effektivare efterfrågas i en enskild fråga än data över partitioner.</span><span class="sxs-lookup"><span data-stu-id="dcc54-529">Also, data in a single partition can be more efficiently queried in a single query than data across partitions.</span></span>
* <span data-ttu-id="dcc54-530">Data som ditt klientprogram inte infoga/uppdatera eller fråga i samma logiska enhet arbete (enskild fråga eller gruppuppdatering) måste finnas i olika partitioner.</span><span class="sxs-lookup"><span data-stu-id="dcc54-530">Data that your client application does not insert/update or query in the same logical unit of work (single query or batch update) should be located in separate partitions.</span></span>  <span data-ttu-id="dcc54-531">Ett viktigt är att det finns ingen gräns för antalet partitionsnycklar i en tabell med miljontals partitionsnycklar är inte ett problem och påverkar inte prestanda.</span><span class="sxs-lookup"><span data-stu-id="dcc54-531">One important note is that there is no limit to the number of partition keys in a single table, so having millions of partition keys is not a problem and will not impact performance.</span></span>  <span data-ttu-id="dcc54-532">Till exempel om ditt program är en populär webbplats med användarinloggning, vara med hjälp av användar-Id som partitionsnyckel ett bra alternativ.</span><span class="sxs-lookup"><span data-stu-id="dcc54-532">For example, if your application is a popular website with user login, using the User Id as the partition key could be a good choice.</span></span>  

#### <a name="hot-partitions"></a><span data-ttu-id="dcc54-533">Varm partitioner</span><span class="sxs-lookup"><span data-stu-id="dcc54-533">Hot Partitions</span></span>
<span data-ttu-id="dcc54-534">En varm partition är en som tar emot en stor andel av trafiken till ett konto och kan inte vara belastningsutjämnade eftersom det är en enskild partition.</span><span class="sxs-lookup"><span data-stu-id="dcc54-534">A hot partition is one that is receiving a disproportionate percentage of the traffic to an account, and cannot be load balanced because it is a single partition.</span></span>  <span data-ttu-id="dcc54-535">I allmänhet skapas varm partitioner på två sätt:</span><span class="sxs-lookup"><span data-stu-id="dcc54-535">In general, hot partitions are created one of two ways:</span></span>  

##### <span data-ttu-id="dcc54-536"><a name="subheading28"></a>Lägg endast till och lägga endast mönster</span><span class="sxs-lookup"><span data-stu-id="dcc54-536"><a name="subheading28"></a>Append Only and Prepend Only patterns</span></span>
<span data-ttu-id="dcc54-537">Mönstret ”Lägg till bara” är en där alla (eller nästan alla) av trafik till en viss PK ökar och minskar enligt den aktuella tiden.</span><span class="sxs-lookup"><span data-stu-id="dcc54-537">The "Append Only" pattern is one where all (or nearly all) of the traffic to a given PK increases and decreases according to the current time.</span></span>  <span data-ttu-id="dcc54-538">Ett exempel är om ditt program används det aktuella datumet som en partitionsnyckel för loggdata.</span><span class="sxs-lookup"><span data-stu-id="dcc54-538">An example is if your application used the current date as a partition key for log data.</span></span>  <span data-ttu-id="dcc54-539">Detta resulterar i alla infogningar går till den senaste partition i tabellen och det går inte att läsa belastningsutjämna eftersom alla skrivningar kommer till slutet av tabellen.</span><span class="sxs-lookup"><span data-stu-id="dcc54-539">This results in all of the inserts going to the last partition in your table, and the system cannot load balance because all of the writes are going to the end of your table.</span></span>  <span data-ttu-id="dcc54-540">Om mängden trafik till denna partition överskrider målet partition nivå skalbarhet, resulterar det i begränsning.</span><span class="sxs-lookup"><span data-stu-id="dcc54-540">If the volume of traffic to that partition exceeds the partition-level scalability target, then it will result in throttling.</span></span>  <span data-ttu-id="dcc54-541">Det är bättre så att trafik som skickas till flera partitioner för att aktivera belastningsutjämning av begäranden i tabellen.</span><span class="sxs-lookup"><span data-stu-id="dcc54-541">It's better to ensure that traffic is sent to multiple partitions, to enable load balance the requests across your table.</span></span>  

##### <span data-ttu-id="dcc54-542"><a name="subheading29"></a>Hög trafik Data</span><span class="sxs-lookup"><span data-stu-id="dcc54-542"><a name="subheading29"></a>High-Traffic Data</span></span>
<span data-ttu-id="dcc54-543">Om din partitioneringsschema resulterar i en enda partition som bara innehåller data som används mycket mer än andra partitioner, kan du också se begränsning som att partitionen närmar sig skalbarhet målet för en enskild partition.</span><span class="sxs-lookup"><span data-stu-id="dcc54-543">If your partitioning scheme results in a single partition that just has data that is far more used than other partitions, you may also see throttling as that partition approaches the scalability target for a single partition.</span></span>  <span data-ttu-id="dcc54-544">Det är bättre att se till att din partitionsschema resulterar i någon enskild partition som närmar sig skalbarhetsmål.</span><span class="sxs-lookup"><span data-stu-id="dcc54-544">It's better to make sure that your partition scheme results in no single partition approaching the scalability targets.</span></span>  

#### <a name="querying"></a><span data-ttu-id="dcc54-545">Fråga</span><span class="sxs-lookup"><span data-stu-id="dcc54-545">Querying</span></span>
<span data-ttu-id="dcc54-546">Det här avsnittet beskrivs beprövade metoder för att fråga efter tabelltjänsten.</span><span class="sxs-lookup"><span data-stu-id="dcc54-546">This section describes proven practices for querying the table service.</span></span>  

##### <span data-ttu-id="dcc54-547"><a name="subheading30"></a>Frågeomfattningen</span><span class="sxs-lookup"><span data-stu-id="dcc54-547"><a name="subheading30"></a>Query Scope</span></span>
<span data-ttu-id="dcc54-548">Det finns flera sätt att ange intervallet för entiteterna som frågas.</span><span class="sxs-lookup"><span data-stu-id="dcc54-548">There are several ways to specify the range of entities to query.</span></span>  <span data-ttu-id="dcc54-549">Här följer en beskrivning av användning av varje.</span><span class="sxs-lookup"><span data-stu-id="dcc54-549">The following is a discussion of the uses of each.</span></span>  

<span data-ttu-id="dcc54-550">I allmänhet undvika genomsökningar (frågor som är större än en enda enhet), men om du måste skannar, försök att ordna data så att dina skanningar hämta de data du behöver utan genomsökning eller returnera stora mängder enheter inte behöver du.</span><span class="sxs-lookup"><span data-stu-id="dcc54-550">In general, avoid scans (queries larger than a single entity), but if you must scan, try to organize your data so that your scans retrieve the data you need without scanning or returning significant amounts of entities you don't need.</span></span>  

###### <a name="point-queries"></a><span data-ttu-id="dcc54-551">Punkt-frågor</span><span class="sxs-lookup"><span data-stu-id="dcc54-551">Point Queries</span></span>
<span data-ttu-id="dcc54-552">En punkt-fråga hämtar exakt en enhet.</span><span class="sxs-lookup"><span data-stu-id="dcc54-552">A point query retrieves exactly one entity.</span></span> <span data-ttu-id="dcc54-553">Det gör du genom att ange både partitionsnyckel och radnyckel för att hämta entiteten.</span><span class="sxs-lookup"><span data-stu-id="dcc54-553">It does this by specifying both the partition key and row key of the entity to retrieve.</span></span> <span data-ttu-id="dcc54-554">De här frågorna är mycket effektivt och du bör använda dem om möjligt.</span><span class="sxs-lookup"><span data-stu-id="dcc54-554">These queries are very efficient, and you should use them wherever possible.</span></span>  

###### <a name="partition-queries"></a><span data-ttu-id="dcc54-555">Partitionen frågor</span><span class="sxs-lookup"><span data-stu-id="dcc54-555">Partition Queries</span></span>
<span data-ttu-id="dcc54-556">En partitionsfrågan är en fråga som hämtar en datamängd som delar en gemensam partitionsnyckel.</span><span class="sxs-lookup"><span data-stu-id="dcc54-556">A partition query is a query that retrieves a set of data that shares a common partition key.</span></span> <span data-ttu-id="dcc54-557">Frågan anger vanligtvis ett intervall av nyckelvärden för raden eller ett intervall med värden för vissa entitetsegenskap förutom en partitionsnyckel.</span><span class="sxs-lookup"><span data-stu-id="dcc54-557">Typically, the query specifies a range of row key values or a range of values for some entity property in addition to a partition key.</span></span> <span data-ttu-id="dcc54-558">Dessa är mindre effektiva än punkt frågor och bör användas sparsamt.</span><span class="sxs-lookup"><span data-stu-id="dcc54-558">These are less efficient than point queries, and should be used sparingly.</span></span>  

###### <a name="table-queries"></a><span data-ttu-id="dcc54-559">Tabell frågor</span><span class="sxs-lookup"><span data-stu-id="dcc54-559">Table Queries</span></span>
<span data-ttu-id="dcc54-560">En tabellfråga är en fråga som hämtar en uppsättning enheter som inte delar en gemensam partitionsnyckel.</span><span class="sxs-lookup"><span data-stu-id="dcc54-560">A table query is a query that retrieves a set of entities that does not share a common partition key.</span></span> <span data-ttu-id="dcc54-561">Dessa frågor är inte effektivt och du bör undvika dem om möjligt.</span><span class="sxs-lookup"><span data-stu-id="dcc54-561">These queries are not efficient and you should avoid them if possible.</span></span>  

##### <span data-ttu-id="dcc54-562"><a name="subheading31"></a>Frågan densitet</span><span class="sxs-lookup"><span data-stu-id="dcc54-562"><a name="subheading31"></a>Query Density</span></span>
<span data-ttu-id="dcc54-563">En annan nyckelfaktor i frågan effektivitet är antalet enheter som returneras jämfört med antal entiteter som genomsöks för att hitta den returnerade uppsättningen.</span><span class="sxs-lookup"><span data-stu-id="dcc54-563">Another key factor in query efficiency is the number of entities returned as compared to the number of entities scanned to find the returned set.</span></span> <span data-ttu-id="dcc54-564">Om ditt program utför en tabellfråga med ett filter för ett värde för egenskapen att bara 1% av data resurser frågan genomsöks 100 entiteter för var en entitet som returneras.</span><span class="sxs-lookup"><span data-stu-id="dcc54-564">If your application performs a table query with a filter for a property value that only 1% of the data shares, the query will scan 100 entities for every one entity it returns.</span></span> <span data-ttu-id="dcc54-565">Tabellen skalbarhetsmål beskrivs tidigare alla avser antalet enheter som har genomsökts och inte antal entiteter som returneras: låg frågan densitet enkelt kan orsaka tabelltjänsten att begränsa ditt program eftersom det måste söka så många entiteter för att hämta entiteten som du letar efter.</span><span class="sxs-lookup"><span data-stu-id="dcc54-565">The table scalability targets discussed previously all relate to the number of entities scanned, and not the number of entities returned: a low query density can easily cause the table service to throttle your application because it must scan so many entities to retrieve the entity you are looking for.</span></span>  <span data-ttu-id="dcc54-566">I avsnittet nedan på [denormalization](#subheading34) mer information om hur du undviker detta.</span><span class="sxs-lookup"><span data-stu-id="dcc54-566">See the section below on [denormalization](#subheading34) for more information on how to avoid this.</span></span>  

##### <a name="limiting-the-amount-of-data-returned"></a><span data-ttu-id="dcc54-567">Begränsa mängden Data som returneras</span><span class="sxs-lookup"><span data-stu-id="dcc54-567">Limiting the Amount of Data Returned</span></span>
###### <span data-ttu-id="dcc54-568"><a name="subheading32"></a>Filtrering</span><span class="sxs-lookup"><span data-stu-id="dcc54-568"><a name="subheading32"></a>Filtering</span></span>
<span data-ttu-id="dcc54-569">Överväg att använda ett filter för att minska storleken på den returnerade uppsättningen om du vet att en fråga returnerar enheter som du inte behöver i klientprogrammet.</span><span class="sxs-lookup"><span data-stu-id="dcc54-569">Where you know that a query will return entities that you don't need in the client application, consider using a filter to reduce the size of the returned set.</span></span> <span data-ttu-id="dcc54-570">När enheterna inte returneras till klienten fortfarande räknas in skalbarhetsgränser, förbättrar programmets prestanda på grund av minskade nätverket nyttolastens storlek och minskat antal entiteter som klientprogrammet måste bearbeta.</span><span class="sxs-lookup"><span data-stu-id="dcc54-570">While the entities not returned to the client still count toward the scalability limits, your application performance will improve because of the reduced network payload size and the reduced number of entities that your client application must process.</span></span>  <span data-ttu-id="dcc54-571">Se över anteckning på [frågan densitet](#subheading31), men – skalbarhetsmål avser antalet enheter som genomsöks, så att en fråga som filtrerar ut många entiteter fortfarande kan resultera i begränsning, även om några enheter returneras.</span><span class="sxs-lookup"><span data-stu-id="dcc54-571">See above note on [Query Density](#subheading31), however – the scalability targets relate to the number of entities scanned, so a query that filters out many entities may still result in throttling, even if few entities are returned.</span></span>  

###### <span data-ttu-id="dcc54-572"><a name="subheading33"></a>Projektion</span><span class="sxs-lookup"><span data-stu-id="dcc54-572"><a name="subheading33"></a>Projection</span></span>
<span data-ttu-id="dcc54-573">Om klientprogrammet måste begränsad uppsättning egenskaper från entiteter i tabellen, kan du använda projektion för att begränsa storleken på datamängden som returnerades.</span><span class="sxs-lookup"><span data-stu-id="dcc54-573">If your client application needs only a limited set of properties from the entities in your table, you can use projection to limit the size of the returned data set.</span></span> <span data-ttu-id="dcc54-574">Precis som med filtrering, bidrar detta till att minska nätverksbelastningen och klienten bearbetning.</span><span class="sxs-lookup"><span data-stu-id="dcc54-574">As with filtering, this helps to reduce network load and client processing.</span></span>  

##### <span data-ttu-id="dcc54-575"><a name="subheading34"></a>Denormalization</span><span class="sxs-lookup"><span data-stu-id="dcc54-575"><a name="subheading34"></a>Denormalization</span></span>
<span data-ttu-id="dcc54-576">Till skillnad från arbete med relationsdatabaser leda beprövade metoder för att effektivt frågar tabelldata till denormalizing dina data.</span><span class="sxs-lookup"><span data-stu-id="dcc54-576">Unlike working with relational databases, the proven practices for efficiently querying table data lead to denormalizing your data.</span></span> <span data-ttu-id="dcc54-577">Som är dubblering av samma data i flera enheter (en för varje nyckel som du kan använda för att hitta data) att minimera antalet enheter som en fråga måste söka igenom för att söka efter data klienten måste i stället att skanna stort antal enheter för att hitta data programmet behöver.</span><span class="sxs-lookup"><span data-stu-id="dcc54-577">That is, duplicating the same data in multiple entities (one for each key you may use to find the data) to minimize the number of entities that a query must scan to find the data the client needs, rather than having to scan large numbers of entities to find the data your application needs.</span></span>  <span data-ttu-id="dcc54-578">Till exempel webbplatser för e-handel, du kanske vill hitta en order både kund-ID: t (mig kundens order) och efter datumet (mig order på ett datum).</span><span class="sxs-lookup"><span data-stu-id="dcc54-578">For example, in an e-commerce website, you may want to find an order both by the customer ID (give me this customer's orders) and by the date (give me orders on a date).</span></span>  <span data-ttu-id="dcc54-579">I Table Storage är det bäst att lagra entiteten (eller en referens till den) två gånger – en gång med tabellnamn, PK och RK för att underlätta hitta av kunden ID, en gång för att underlätta söka efter datumet.</span><span class="sxs-lookup"><span data-stu-id="dcc54-579">In Table Storage, it is best to store the entity (or a reference to it) twice – once with Table Name, PK, and RK to facilitate finding by customer ID, once to facilitate finding it by the date.</span></span>  

#### <a name="insertupdatedelete"></a><span data-ttu-id="dcc54-580">Insert/Update/Delete</span><span class="sxs-lookup"><span data-stu-id="dcc54-580">Insert/Update/Delete</span></span>
<span data-ttu-id="dcc54-581">Det här avsnittet beskrivs beprövade metoder för att ändra entiteter som lagras i tabelltjänsten.</span><span class="sxs-lookup"><span data-stu-id="dcc54-581">This section describes proven practices for modifying entities stored in the table service.</span></span>  

##### <span data-ttu-id="dcc54-582"><a name="subheading35"></a>Batchbearbetning</span><span class="sxs-lookup"><span data-stu-id="dcc54-582"><a name="subheading35"></a>Batching</span></span>
<span data-ttu-id="dcc54-583">Batchtransaktioner är kända som entiteten grupp transaktioner (ETG) i Azure Storage; alla åtgärder i en ETG måste finnas på en partition i en tabell.</span><span class="sxs-lookup"><span data-stu-id="dcc54-583">Batch transactions are known as Entity Group Transactions (ETG) in Azure Storage; all the operations within an ETG must be on a single partition in a single table.</span></span> <span data-ttu-id="dcc54-584">Om möjligt bör du använda ETGs för att utföra infogningar, uppdateringar och borttagningar i batchar.</span><span class="sxs-lookup"><span data-stu-id="dcc54-584">Where possible, use ETGs to perform inserts, updates, and deletes in batches.</span></span> <span data-ttu-id="dcc54-585">Detta minskar antalet sändningar från ditt klientprogram till servern, minskar antalet fakturerbar transaktioner (en ETG räknas som en enda transaktion för fakturering och kan innehålla upp till 100 lagringsåtgärder) och aktiverar atomiska uppdateringar (alla åtgärder lyckas eller misslyckas inom en ETG alla).</span><span class="sxs-lookup"><span data-stu-id="dcc54-585">This reduces the number of round trips from your client application to the server, reduces the number of billable transactions (an ETG counts as a single transaction for billing purposes and can contain up to 100 storage operations), and enables atomic updates (all operations succeed or all fail within an ETG).</span></span> <span data-ttu-id="dcc54-586">Miljöer med hög fördröjning till exempel från mobila enheter kommer avsevärt fördelarna med att använda ETGs.</span><span class="sxs-lookup"><span data-stu-id="dcc54-586">Environments with high latencies such as mobile devices will benefit greatly from using ETGs.</span></span>  

##### <span data-ttu-id="dcc54-587"><a name="subheading36"></a>Upsert</span><span class="sxs-lookup"><span data-stu-id="dcc54-587"><a name="subheading36"></a>Upsert</span></span>
<span data-ttu-id="dcc54-588">Användningstabell **Upsert** åtgärder när så är möjligt.</span><span class="sxs-lookup"><span data-stu-id="dcc54-588">Use table **Upsert** operations wherever possible.</span></span> <span data-ttu-id="dcc54-589">Det finns två typer av **Upsert**, som kan vara effektivare än traditionella **infoga** och **uppdatering** åtgärder:</span><span class="sxs-lookup"><span data-stu-id="dcc54-589">There are two types of **Upsert**, both of which can be more efficient than a traditional **Insert** and **Update** operations:</span></span>  

* <span data-ttu-id="dcc54-590">**InsertOrMerge**: Använd den här när du vill överföra en delmängd av enhetens egenskaper, men är osäker på om entiteten finns redan.</span><span class="sxs-lookup"><span data-stu-id="dcc54-590">**InsertOrMerge**: Use this when you want to upload a subset of the entity's properties, but aren't sure whether the entity already exists.</span></span> <span data-ttu-id="dcc54-591">Om entiteten finns det här anropet uppdateras de egenskaper som ingår i den **Upsert** åtgärd och lämnar alla befintliga egenskaper som de är, om entiteten inte finns, infogas ny entitet.</span><span class="sxs-lookup"><span data-stu-id="dcc54-591">If the entity exists, this call updates the properties included in the **Upsert** operation, and leaves all existing properties as they are, if the entity does not exist, it inserts the new entity.</span></span> <span data-ttu-id="dcc54-592">Detta liknar att projektion har använts i en fråga i att du behöver bara ladda upp de egenskaper som ändrar.</span><span class="sxs-lookup"><span data-stu-id="dcc54-592">This is similar to using projection in a query, in that you only need to upload the properties that are changing.</span></span>
* <span data-ttu-id="dcc54-593">**InsertOrReplace**: Använd den här när du vill överföra en helt ny entitet, men du är osäker på om den redan finns.</span><span class="sxs-lookup"><span data-stu-id="dcc54-593">**InsertOrReplace**: Use this when you want to upload an entirely new entity, but you aren't sure whether it already exists.</span></span> <span data-ttu-id="dcc54-594">Du bör endast använda den när du vet att nyligen uppladdade entiteten är helt korrekt eftersom det helt skriver över den gamla entiteten.</span><span class="sxs-lookup"><span data-stu-id="dcc54-594">You should only use this when you know that the newly uploaded entity is entirely correct because it completely overwrites the old entity.</span></span> <span data-ttu-id="dcc54-595">Till exempel vill du uppdatera en entitet som lagrar användarens aktuella plats oavsett om programmet har tidigare lagrad lokaliseringsuppgifter för användaren. den nya plats entiteten är klar och du behöver inte någon information från tidigare entiteter.</span><span class="sxs-lookup"><span data-stu-id="dcc54-595">For example, you want to update the entity that stores a user's current location regardless of whether or not the application has previously stored location data for the user; the new location entity is complete, and you do not need any information from any previous entity.</span></span>

##### <span data-ttu-id="dcc54-596"><a name="subheading37"></a>Lagra dataserien i en enda entitet</span><span class="sxs-lookup"><span data-stu-id="dcc54-596"><a name="subheading37"></a>Storing Data Series in a Single Entity</span></span>
<span data-ttu-id="dcc54-597">Ibland kan ett program lagrar en serie med data som ofta behöver hämta allt samtidigt: ett program kan till exempel Spåra processoranvändning över tid för att rita ett rullande diagram av data från de senaste 24 timmarna.</span><span class="sxs-lookup"><span data-stu-id="dcc54-597">Sometimes, an application stores a series of data that it frequently needs to retrieve all at once: for example, an application might track CPU usage over time in order to plot a rolling chart of the data from the last 24 hours.</span></span> <span data-ttu-id="dcc54-598">En metod är att tabellen enheter per timme, med varje entitet som representerar en specifik timme och lagrar CPU-användningen för den timmen.</span><span class="sxs-lookup"><span data-stu-id="dcc54-598">One approach is to have one table entity per hour, with each entity representing a specific hour and storing the CPU usage for that hour.</span></span> <span data-ttu-id="dcc54-599">Programmet måste hämta data från de senaste 24 timmarna för innehavare för att rita dessa data.</span><span class="sxs-lookup"><span data-stu-id="dcc54-599">To plot this data, the application needs to retrieve the entities holding the data from the 24 most recent hours.</span></span>  

<span data-ttu-id="dcc54-600">Du kan också programmet kan lagra CPU-användningen för varje timme som en separat av en enda entitet: för att uppdatera varje timme, programmet kan använda en enda **InsertOrMerge Upsert** anrop för att uppdatera värdet för den senaste timmen.</span><span class="sxs-lookup"><span data-stu-id="dcc54-600">Alternatively, your application could store the CPU usage for each hour as a separate property of a single entity: to update each hour, your application can use a single **InsertOrMerge Upsert** call to update the value for the most recent hour.</span></span> <span data-ttu-id="dcc54-601">Om du vill rita data programmet behöver bara en enda entitet i stället för 24, för ett mycket effektivt frågan att hämta (se ovan diskussion på [fråga scope](#subheading30)).</span><span class="sxs-lookup"><span data-stu-id="dcc54-601">To plot the data, the application only needs to retrieve a single entity instead of 24, making for a very efficient query (see above discussion on [query scope](#subheading30)).</span></span>

##### <span data-ttu-id="dcc54-602"><a name="subheading38"></a>Lagra strukturerade data i BLOB</span><span class="sxs-lookup"><span data-stu-id="dcc54-602"><a name="subheading38"></a>Storing structured data in blobs</span></span>
<span data-ttu-id="dcc54-603">Ibland strukturerade data känns som det ska gå i tabeller, men intervallen för entiteter hämtas alltid tillsammans och kan batch infogas.</span><span class="sxs-lookup"><span data-stu-id="dcc54-603">Sometimes structured data feels like it should go in tables, but ranges of entities are always retrieved together and can be batch inserted.</span></span>  <span data-ttu-id="dcc54-604">Ett bra exempel på detta är en loggfil.</span><span class="sxs-lookup"><span data-stu-id="dcc54-604">A good example of this is a log file.</span></span>  <span data-ttu-id="dcc54-605">I det här fallet kan du batch-flera minuters loggar, infoga dem och sedan du hämtar alltid flera minuter loggar i taget samt.</span><span class="sxs-lookup"><span data-stu-id="dcc54-605">In this case, you can batch several minutes of logs, insert them, and then you are always retrieving several minutes of logs at a time as well.</span></span>  <span data-ttu-id="dcc54-606">I det här fallet för prestanda är det bättre att använda blobbar i stället för tabeller, eftersom du kan avsevärt minska antalet objekt skrivs/returnerade, samt vanligtvis antalet begäranden som behöver.</span><span class="sxs-lookup"><span data-stu-id="dcc54-606">In this case, for performance, it's better to use blobs instead of tables, since you can significantly reduce the number of objects written/returned, as well as usually the number of requests that need made.</span></span>  

## <a name="queues"></a><span data-ttu-id="dcc54-607">Köer</span><span class="sxs-lookup"><span data-stu-id="dcc54-607">Queues</span></span>
<span data-ttu-id="dcc54-608">Förutom beprövade metoder för [alla tjänster](#allservices) som beskrivs ovan, följande beprövade metoder som gäller specifikt för kötjänsten.</span><span class="sxs-lookup"><span data-stu-id="dcc54-608">In addition to the proven practices for [All Services](#allservices) described previously, the following proven practices apply specifically to the queue service.</span></span>  

### <span data-ttu-id="dcc54-609"><a name="subheading39"></a>Skalbarhetsgränser</span><span class="sxs-lookup"><span data-stu-id="dcc54-609"><a name="subheading39"></a>Scalability Limits</span></span>
<span data-ttu-id="dcc54-610">En enskild kö kan bearbeta ungefär 2 000 meddelanden (1KB som är varje) per sekund (varje AddMessage och GetMessage DeleteMessage antal som ett meddelande här).</span><span class="sxs-lookup"><span data-stu-id="dcc54-610">A single queue can process approximately 2,000 messages (1KB each) per second (each AddMessage, GetMessage, and DeleteMessage count as a message here).</span></span> <span data-ttu-id="dcc54-611">Om detta inte är tillräckligt för ditt program bör du använda flera köer och sprids dem meddelanden.</span><span class="sxs-lookup"><span data-stu-id="dcc54-611">If this is insufficient for your application, you should use multiple queues and spread the messages across them.</span></span>  

<span data-ttu-id="dcc54-612">Visa den aktuella skalbarhetsmål på [Azure Storage skalbarhets- och prestandamål](storage-scalability-targets.md).</span><span class="sxs-lookup"><span data-stu-id="dcc54-612">View current scalability targets at [Azure Storage Scalability and Performance Targets](storage-scalability-targets.md).</span></span>  

### <span data-ttu-id="dcc54-613"><a name="subheading40"></a>Nagle ut</span><span class="sxs-lookup"><span data-stu-id="dcc54-613"><a name="subheading40"></a>Nagle Off</span></span>
<span data-ttu-id="dcc54-614">Se avsnittet om konfigurationen som beskrivs algoritmen Nagle – Nagle algoritmen är vanligtvis bra för prestanda för kön begäranden och bör du inaktivera den.</span><span class="sxs-lookup"><span data-stu-id="dcc54-614">See the section on table configuration that discusses the Nagle algorithm — the Nagle algorithm is generally bad for the performance of queue requests, and you should disable it.</span></span>  

### <span data-ttu-id="dcc54-615"><a name="subheading41"></a>Meddelandestorlek</span><span class="sxs-lookup"><span data-stu-id="dcc54-615"><a name="subheading41"></a>Message Size</span></span>
<span data-ttu-id="dcc54-616">Kön prestanda och skalbarhet minskas när meddelandet storlek ökar.</span><span class="sxs-lookup"><span data-stu-id="dcc54-616">Queue performance and scalability decreases as message size increases.</span></span> <span data-ttu-id="dcc54-617">Du bör placera bara den information som mottagaren måste i ett meddelande.</span><span class="sxs-lookup"><span data-stu-id="dcc54-617">You should place only the information the receiver needs in a message.</span></span>  

### <span data-ttu-id="dcc54-618"><a name="subheading42"></a>Batch-hämtning</span><span class="sxs-lookup"><span data-stu-id="dcc54-618"><a name="subheading42"></a>Batch Retrieval</span></span>
<span data-ttu-id="dcc54-619">Du kan hämta upp till 32 meddelanden från en kö i en enda åtgärd.</span><span class="sxs-lookup"><span data-stu-id="dcc54-619">You can retrieve up to 32 messages from a queue in a single operation.</span></span> <span data-ttu-id="dcc54-620">Detta minskar antalet turer fram och tillbaka från klientprogrammet, vilket är särskilt användbart för företagsmiljöer, t.ex mobila enheter med hög latens.</span><span class="sxs-lookup"><span data-stu-id="dcc54-620">This can reduce the number of roundtrips from the client application, which is especially useful for environments, such as mobile devices, with high latency.</span></span>  

### <span data-ttu-id="dcc54-621"><a name="subheading43"></a>Avsökningsintervall för kön</span><span class="sxs-lookup"><span data-stu-id="dcc54-621"><a name="subheading43"></a>Queue Polling Interval</span></span>
<span data-ttu-id="dcc54-622">De flesta program att söka efter meddelanden från en kö som kan vara något av de största källorna till transaktioner för programmet.</span><span class="sxs-lookup"><span data-stu-id="dcc54-622">Most applications poll for messages from a queue, which can be one of the largest sources of transactions for that application.</span></span> <span data-ttu-id="dcc54-623">Välj din avsökningsintervallet klokt: avsökning för ofta kan orsaka tillämpningsprogrammet att närma skalbarhetsmål för kön.</span><span class="sxs-lookup"><span data-stu-id="dcc54-623">Select your polling interval wisely: polling too frequently could cause your application to approach the scalability targets for the queue.</span></span> <span data-ttu-id="dcc54-624">På 200 000 transaktioner för $0,01 (vid tidpunkten för skrivning) är en enskild processor avsökning när varje sekund för en månad skulle kosta mindre än 15 cent så kostnaden dock inte vanligtvis en faktor som påverkar ditt val av avsökningsintervallet.</span><span class="sxs-lookup"><span data-stu-id="dcc54-624">However, at 200,000 transactions for $0.01 (at the time of writing), a single processor polling once every second for a month would cost less than 15 cents so cost is not typically a factor that affects your choice of polling interval.</span></span>  

<span data-ttu-id="dcc54-625">Uppdaterade kostnadsinformation finns [priser för Azure Storage](https://azure.microsoft.com/pricing/details/storage/).</span><span class="sxs-lookup"><span data-stu-id="dcc54-625">For up-to-date cost information, see [Azure Storage Pricing](https://azure.microsoft.com/pricing/details/storage/).</span></span>  

### <span data-ttu-id="dcc54-626"><a name="subheading44"></a>UpdateMessage</span><span class="sxs-lookup"><span data-stu-id="dcc54-626"><a name="subheading44"></a>UpdateMessage</span></span>
<span data-ttu-id="dcc54-627">Du kan använda **UpdateMessage** att öka tidsgränsen för osynlighet eller för att uppdatera information om tillstånd för ett meddelande.</span><span class="sxs-lookup"><span data-stu-id="dcc54-627">You can use **UpdateMessage** to increase the invisibility timeout or to update state information of a message.</span></span> <span data-ttu-id="dcc54-628">Detta är kraftfulla, Kom ihåg att varje **UpdateMessage** åtgärden räknar mot mål för skalbarhet.</span><span class="sxs-lookup"><span data-stu-id="dcc54-628">While this is powerful, remember that each **UpdateMessage** operation counts towards the scalability target.</span></span> <span data-ttu-id="dcc54-629">Det kan dock vara ett mycket effektivare sätt än med ett arbetsflöde som skickar ett jobb från en kö till nästa, eftersom varje steg i jobbet har slutförts.</span><span class="sxs-lookup"><span data-stu-id="dcc54-629">However, this can be a much more efficient approach than having a workflow that passes a job from one queue to the next, as each step of the job is completed.</span></span> <span data-ttu-id="dcc54-630">Med hjälp av den **UpdateMessage** åtgärden tillåter programmet att spara jobbets status till meddelandet och sedan fortsätta arbeta i stället för queuing meddelandet för nästa steg i jobbet igen varje gång ett steg har slutförts.</span><span class="sxs-lookup"><span data-stu-id="dcc54-630">Using the **UpdateMessage** operation allows your application to save the job state to the message and then continue working, instead of re-queuing the message for the next step of the job every time a step completes.</span></span>  

<span data-ttu-id="dcc54-631">Mer information finns i artikeln [så här: ändra innehållet i ett meddelande i kön](../queues/storage-dotnet-how-to-use-queues.md#change-the-contents-of-a-queued-message).</span><span class="sxs-lookup"><span data-stu-id="dcc54-631">For more information, see the article [How to: Change the contents of a queued message](../queues/storage-dotnet-how-to-use-queues.md#change-the-contents-of-a-queued-message).</span></span>  

### <span data-ttu-id="dcc54-632"><a name="subheading45"></a>Programarkitektur</span><span class="sxs-lookup"><span data-stu-id="dcc54-632"><a name="subheading45"></a>Application architecture</span></span>
<span data-ttu-id="dcc54-633">Du bör använda köer för att göra din programarkitektur skalbara.</span><span class="sxs-lookup"><span data-stu-id="dcc54-633">You should use queues to make your application architecture scalable.</span></span> <span data-ttu-id="dcc54-634">Här nedan listas några metoder som du kan använda köer för att göra programmet mer skalbar:</span><span class="sxs-lookup"><span data-stu-id="dcc54-634">The following lists some ways you can use queues to make your application more scalable:</span></span>  

* <span data-ttu-id="dcc54-635">Du kan använda köer för att skapa eftersläpningar för bearbetning och Utjämna arbetsbelastningar i ditt program.</span><span class="sxs-lookup"><span data-stu-id="dcc54-635">You can use queues to create backlogs of work for processing and smooth out workloads in your application.</span></span> <span data-ttu-id="dcc54-636">Du kan till exempel köa-begäranden från användare arbetar processor, till exempel storleksändring överförda bilder.</span><span class="sxs-lookup"><span data-stu-id="dcc54-636">For example, you could queue up requests from users to perform processor intensive work such as resizing uploaded images.</span></span>
* <span data-ttu-id="dcc54-637">Du kan använda köer för att frikoppla delar av ditt program så att du kan skala oberoende av varandra.</span><span class="sxs-lookup"><span data-stu-id="dcc54-637">You can use queues to decouple parts of your application so that you can scale them independently.</span></span> <span data-ttu-id="dcc54-638">Till exempel placera en webbklientdel undersökningsresultat från användare i en kö för senare analys och lagring.</span><span class="sxs-lookup"><span data-stu-id="dcc54-638">For example, a web front-end could place survey results from users into a queue for later analysis and storage.</span></span> <span data-ttu-id="dcc54-639">Du kan lägga till flera worker rollinstanser för att bearbeta kön data vid behov.</span><span class="sxs-lookup"><span data-stu-id="dcc54-639">You could add more worker role instances to process the queue data as required.</span></span>  

## <a name="conclusion"></a><span data-ttu-id="dcc54-640">Slutsats</span><span class="sxs-lookup"><span data-stu-id="dcc54-640">Conclusion</span></span>
<span data-ttu-id="dcc54-641">Den här artikeln beskrivs några av de vanligaste, beprövade metoder för att optimera prestanda när du använder Azure Storage.</span><span class="sxs-lookup"><span data-stu-id="dcc54-641">This article discussed some of the most common, proven practices for optimizing performance when using Azure Storage.</span></span> <span data-ttu-id="dcc54-642">Vi rekommenderar att alla programutvecklare utvärderar sina program med hjälp av ovanstående metoder, och överväger att följa rekommendationerna för att få ut mesta möjliga av de program som använder sig av Azure-lagring.</span><span class="sxs-lookup"><span data-stu-id="dcc54-642">We encourage every application developer to assess their application against each of the above practices and consider acting on the recommendations to get great performance for their applications that use Azure Storage.</span></span>