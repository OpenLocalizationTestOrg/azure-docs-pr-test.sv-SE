---
title: "aaaService Fabric tillförlitliga aktörer översikt | Microsoft Docs"
description: Introduktion toohello Service Fabric Reliable Actors programmeringsmodell.
services: service-fabric
documentationcenter: .net
author: vturecek
manager: timlt
editor: 
ms.assetid: 7fdad07f-f2d6-4c74-804d-e0d56131f060
ms.service: service-fabric
ms.devlang: dotnet
ms.topic: article
ms.tgt_pltfrm: NA
ms.workload: NA
ms.date: 06/29/2017
ms.author: vturecek
ms.openlocfilehash: ab010cbf936c6cf723b3d453ef95a9bf51f76c95
ms.sourcegitcommit: 523283cc1b3c37c428e77850964dc1c33742c5f0
ms.translationtype: MT
ms.contentlocale: sv-SE
ms.lasthandoff: 10/06/2017
---
# <a name="introduction-tooservice-fabric-reliable-actors"></a><span data-ttu-id="dbf74-103">Introduktion tooService Fabric Reliable Actors</span><span class="sxs-lookup"><span data-stu-id="dbf74-103">Introduction tooService Fabric Reliable Actors</span></span>
<span data-ttu-id="dbf74-104">Reliable Actors är ett ramverk för Service Fabric-program som baseras på hello [virtuella aktören](http://research.microsoft.com/en-us/projects/orleans/) mönster.</span><span class="sxs-lookup"><span data-stu-id="dbf74-104">Reliable Actors is a Service Fabric application framework based on hello [Virtual Actor](http://research.microsoft.com/en-us/projects/orleans/) pattern.</span></span> <span data-ttu-id="dbf74-105">hello tillförlitliga aktörer API är en enkeltrådig programmeringsmodell som bygger på hello skalbarhet och tillförlitlighet garantier från Service Fabric.</span><span class="sxs-lookup"><span data-stu-id="dbf74-105">hello Reliable Actors API provides a single-threaded programming model built on hello scalability and reliability guarantees provided by Service Fabric.</span></span>

## <a name="what-are-actors"></a><span data-ttu-id="dbf74-106">Vad är aktörer?</span><span class="sxs-lookup"><span data-stu-id="dbf74-106">What are Actors?</span></span>
<span data-ttu-id="dbf74-107">En aktör är en isolerad, oberoende beräknings- och tillstånd med Enkeltrådig körning.</span><span class="sxs-lookup"><span data-stu-id="dbf74-107">An actor is an isolated, independent unit of compute and state with single-threaded execution.</span></span> <span data-ttu-id="dbf74-108">Hej [aktören mönster](https://en.wikipedia.org/wiki/Actor_model) är en beräkningar modell för samtidiga eller distribuerade system som ett stort antal dessa aktörer kan köras samtidigt och oberoende av varandra.</span><span class="sxs-lookup"><span data-stu-id="dbf74-108">hello [actor pattern](https://en.wikipedia.org/wiki/Actor_model) is a computational model for concurrent or distributed systems in which a large number of these actors can execute simultaneously and independently of each other.</span></span> <span data-ttu-id="dbf74-109">Aktörer kan kommunicera med varandra och de kan skapa flera aktörer.</span><span class="sxs-lookup"><span data-stu-id="dbf74-109">Actors can communicate with each other and they can create more actors.</span></span>

### <a name="when-toouse-reliable-actors"></a><span data-ttu-id="dbf74-110">När toouse Reliable Actors</span><span class="sxs-lookup"><span data-stu-id="dbf74-110">When toouse Reliable Actors</span></span>
<span data-ttu-id="dbf74-111">Service Fabric Reliable Actors är en implementering av hello aktören designmönstret.</span><span class="sxs-lookup"><span data-stu-id="dbf74-111">Service Fabric Reliable Actors is an implementation of hello actor design pattern.</span></span> <span data-ttu-id="dbf74-112">Precis som med alla programvara designmönstret passar hello beslut om görs toouse ett specifikt mönster baserat på om huruvida en programvara utforma problemet hello mönster.</span><span class="sxs-lookup"><span data-stu-id="dbf74-112">As with any software design pattern, hello decision whether toouse a specific pattern is made based on whether or not a software design problem fits hello pattern.</span></span>

<span data-ttu-id="dbf74-113">Även om hello aktören designmönstret kan vara ett bra val tooa antal distribuerade system problem och scenarier, noggrant övervägande av hello begränsningarna för hello mönster och hello framework implementera måste göras.</span><span class="sxs-lookup"><span data-stu-id="dbf74-113">Although hello actor design pattern can be a good fit tooa number of distributed systems problems and scenarios, careful consideration of hello constraints of hello pattern and hello framework implementing it must be made.</span></span> <span data-ttu-id="dbf74-114">Som en allmän vägledning Tänk hello aktören mönster toomodel ditt problem eller scenario om:</span><span class="sxs-lookup"><span data-stu-id="dbf74-114">As general guidance, consider hello actor pattern toomodel your problem or scenario if:</span></span>

* <span data-ttu-id="dbf74-115">Sidan problem innebär att ett stort antal (tusentalsavgränsare eller mer) liten, oberoende och isolerade enheter av tillstånd och logik.</span><span class="sxs-lookup"><span data-stu-id="dbf74-115">Your problem space involves a large number (thousands or more) of small, independent, and isolated units of state and logic.</span></span>
* <span data-ttu-id="dbf74-116">Vill du toowork med Enkeltrådig objekt som inte kräver betydande interaktion från externa komponenter, inklusive frågor tillstånd på en uppsättning aktörer.</span><span class="sxs-lookup"><span data-stu-id="dbf74-116">You want toowork with single-threaded objects that do not require significant interaction from external components, including querying state across a set of actors.</span></span>
* <span data-ttu-id="dbf74-117">Aktören-instanser blockera inte anropare med oväntade fördröjningar genom att utfärda o-åtgärder.</span><span class="sxs-lookup"><span data-stu-id="dbf74-117">Your actor instances won't block callers with unpredictable delays by issuing I/O operations.</span></span>

## <a name="actors-in-service-fabric"></a><span data-ttu-id="dbf74-118">Aktörer i Service Fabric</span><span class="sxs-lookup"><span data-stu-id="dbf74-118">Actors in Service Fabric</span></span>
<span data-ttu-id="dbf74-119">I Service Fabric aktörer implementeras i hello Reliable Actors framework: ett programramverk för aktören-mönster-baserade byggt ovanpå [Service Fabric Reliable Services](service-fabric-reliable-services-introduction.md).</span><span class="sxs-lookup"><span data-stu-id="dbf74-119">In Service Fabric, actors are implemented in hello Reliable Actors framework: An actor-pattern-based application framework built on top of [Service Fabric Reliable Services](service-fabric-reliable-services-introduction.md).</span></span> <span data-ttu-id="dbf74-120">Varje tillförlitliga aktören-tjänst som du skriver är faktiskt en partitionerad tillståndskänslig tillförlitlig tjänst.</span><span class="sxs-lookup"><span data-stu-id="dbf74-120">Each Reliable Actor service you write is actually a partitioned, stateful Reliable Service.</span></span>

<span data-ttu-id="dbf74-121">Varje aktören har definierats som en instans av en aktörstyp av, identiska toohello sätt en .NET-objekt är en instans av en .NET-typen.</span><span class="sxs-lookup"><span data-stu-id="dbf74-121">Every actor is defined as an instance of an actor type, identical toohello way a .NET object is an instance of a .NET type.</span></span> <span data-ttu-id="dbf74-122">Till exempel kan det finnas en aktörstyp som implementerar hello funktionerna i en kalkylator och det kan finnas flera aktörer av den typen som distribueras på olika noder i ett kluster.</span><span class="sxs-lookup"><span data-stu-id="dbf74-122">For example, there may be an actor type that implements hello functionality of a calculator and there could be many actors of that type that are distributed on various nodes across a cluster.</span></span> <span data-ttu-id="dbf74-123">Varje sådan aktören identifieras unikt genom ett aktören-ID.</span><span class="sxs-lookup"><span data-stu-id="dbf74-123">Each such actor is uniquely identified by an actor ID.</span></span>

### <a name="actor-lifetime"></a><span data-ttu-id="dbf74-124">Aktören livslängd</span><span class="sxs-lookup"><span data-stu-id="dbf74-124">Actor Lifetime</span></span>
<span data-ttu-id="dbf74-125">Service Fabric aktörer är virtuell, vilket innebär att deras livstid inte är bundet tootheir InMemory-representation.</span><span class="sxs-lookup"><span data-stu-id="dbf74-125">Service Fabric actors are virtual, meaning that their lifetime is not tied tootheir in-memory representation.</span></span> <span data-ttu-id="dbf74-126">Därför kan behöver de inte toobe explicit skapas eller förstörs.</span><span class="sxs-lookup"><span data-stu-id="dbf74-126">As a result, they do not need toobe explicitly created or destroyed.</span></span> <span data-ttu-id="dbf74-127">hello Reliable Actors runtime aktiveras automatiskt en aktören hello första gången som den tar emot en begäran om att aktören-ID.</span><span class="sxs-lookup"><span data-stu-id="dbf74-127">hello Reliable Actors runtime automatically activates an actor hello first time it receives a request for that actor ID.</span></span> <span data-ttu-id="dbf74-128">Om en aktör inte används för en viss tidsperiod, hello Reliable Actors runtime skräp-samlar in hello InMemory-objektet.</span><span class="sxs-lookup"><span data-stu-id="dbf74-128">If an actor is not used for a period of time, hello Reliable Actors runtime garbage-collects hello in-memory object.</span></span> <span data-ttu-id="dbf74-129">Den kommer också upprätthålla kunskap om hello aktören förekomsten ska måste toobe igen senare.</span><span class="sxs-lookup"><span data-stu-id="dbf74-129">It will also maintain knowledge of hello actor's existence should it need toobe reactivated later.</span></span> <span data-ttu-id="dbf74-130">Mer information finns i [aktören livscykel och skräp samling](service-fabric-reliable-actors-lifecycle.md).</span><span class="sxs-lookup"><span data-stu-id="dbf74-130">For more details, see [Actor lifecycle and garbage collection](service-fabric-reliable-actors-lifecycle.md).</span></span>

<span data-ttu-id="dbf74-131">Denna virtuella aktören livstid framställning har vissa varningar på grund av hello virtuella aktören modellen och faktum hello Reliable Actors implementering avviker ibland från den här modellen.</span><span class="sxs-lookup"><span data-stu-id="dbf74-131">This virtual actor lifetime abstraction carries some caveats as a result of hello virtual actor model, and in fact hello Reliable Actors implementation deviates at times from this model.</span></span>

* <span data-ttu-id="dbf74-132">En aktör aktiveras automatiskt (och en aktör objektet toobe konstrueras) hello första gången ett meddelande skickas tooits aktören-ID.</span><span class="sxs-lookup"><span data-stu-id="dbf74-132">An actor is automatically activated (causing an actor object toobe constructed) hello first time a message is sent tooits actor ID.</span></span> <span data-ttu-id="dbf74-133">Efter en viss tidsperiod samlas hello aktören objekt in som skräp.</span><span class="sxs-lookup"><span data-stu-id="dbf74-133">After some period of time, hello actor object is garbage collected.</span></span> <span data-ttu-id="dbf74-134">I hello orsakar framtiden kan använda hello aktörs-ID igen, en ny aktören objektet toobe konstrueras.</span><span class="sxs-lookup"><span data-stu-id="dbf74-134">In hello future, using hello actor ID again, causes a new actor object toobe constructed.</span></span> <span data-ttu-id="dbf74-135">En aktörstillstånd användbara under begränsad livslängd hello objekt när lagras i hello tillståndshanterare.</span><span class="sxs-lookup"><span data-stu-id="dbf74-135">An actor's state outlives hello object's lifetime when stored in hello state manager.</span></span>
* <span data-ttu-id="dbf74-136">Anropar någon aktören för aktörs-ID aktiverar att aktören.</span><span class="sxs-lookup"><span data-stu-id="dbf74-136">Calling any actor method for an actor ID activates that actor.</span></span> <span data-ttu-id="dbf74-137">Därför har aktören typer sin konstruktor anropas implicit av hello runtime.</span><span class="sxs-lookup"><span data-stu-id="dbf74-137">For this reason, actor types have their constructor called implicitly by hello runtime.</span></span> <span data-ttu-id="dbf74-138">Därför går inte att klientkod ange parametrarna toohello aktören typens konstruktor, även om parametrar kan överföras toohello aktören konstruktorn av själva hello-tjänsten.</span><span class="sxs-lookup"><span data-stu-id="dbf74-138">Therefore, client code cannot pass parameters toohello actor type's constructor, although parameters may be passed toohello actor's constructor by hello service itself.</span></span> <span data-ttu-id="dbf74-139">hello resultatet är att aktörer kan konstrueras i en delvis initierats tillstånd med hello gång andra metoder anropas, om hello aktören kräver initieringsparametrar hello-klient.</span><span class="sxs-lookup"><span data-stu-id="dbf74-139">hello result is that actors may be constructed in a partially-initialized state by hello time other methods are called on it, if hello actor requires initialization parameters from hello client.</span></span> <span data-ttu-id="dbf74-140">Det finns ingen enskild startpunkt för hello aktivering av en aktör hello-klient.</span><span class="sxs-lookup"><span data-stu-id="dbf74-140">There is no single entry point for hello activation of an actor from hello client.</span></span>
* <span data-ttu-id="dbf74-141">Även om Reliable Actors skapa implicit aktören objekt. du har hello möjlighet tooexplicitly ta bort en aktör och dess tillstånd.</span><span class="sxs-lookup"><span data-stu-id="dbf74-141">Although Reliable Actors implicitly create actor objects; you do have hello ability tooexplicitly delete an actor and its state.</span></span>

### <a name="distribution-and-failover"></a><span data-ttu-id="dbf74-142">Distribution och växling vid fel</span><span class="sxs-lookup"><span data-stu-id="dbf74-142">Distribution and failover</span></span>
<span data-ttu-id="dbf74-143">tooprovide skalbarhet och tillförlitlighet, Service Fabric distribuerar aktörer i hela klustret hello och automatiskt migrerar dem från felande noder toohealthy dem efter behov.</span><span class="sxs-lookup"><span data-stu-id="dbf74-143">tooprovide scalability and reliability, Service Fabric distributes actors throughout hello cluster and automatically migrates them from failed nodes toohealthy ones as required.</span></span> <span data-ttu-id="dbf74-144">Detta är en abstraktion via en [partitionerade och tillståndskänsliga tillförlitlig tjänst](service-fabric-concepts-partitioning.md).</span><span class="sxs-lookup"><span data-stu-id="dbf74-144">This is an abstraction over a [partitioned, stateful Reliable Service](service-fabric-concepts-partitioning.md).</span></span> <span data-ttu-id="dbf74-145">Distribution, skalbarhet, tillförlitlighet och automatisk redundans har angetts tack vare hello fakta som körs inom en tillståndskänslig tillförlitlig tjänst som kallas hello aktörer *aktören tjänsten*.</span><span class="sxs-lookup"><span data-stu-id="dbf74-145">Distribution, scalability, reliability, and automatic failover are all provided by virtue of hello fact that actors are running inside a stateful Reliable Service called hello *Actor Service*.</span></span>

<span data-ttu-id="dbf74-146">Aktörer är fördelade på hello partitioner i hello aktören Service och dessa partitioner är fördelade på hello noder i ett Service Fabric-kluster.</span><span class="sxs-lookup"><span data-stu-id="dbf74-146">Actors are distributed across hello partitions of hello Actor Service, and those partitions are distributed across hello nodes in a Service Fabric cluster.</span></span> <span data-ttu-id="dbf74-147">Varje tjänst partition innehåller en uppsättning aktörer.</span><span class="sxs-lookup"><span data-stu-id="dbf74-147">Each service partition contains a set of actors.</span></span> <span data-ttu-id="dbf74-148">Service Fabric hanterar distribution och redundans för hello service partitioner.</span><span class="sxs-lookup"><span data-stu-id="dbf74-148">Service Fabric manages distribution and failover of hello service partitions.</span></span>

<span data-ttu-id="dbf74-149">Till exempel distribuera en aktören tjänsten med nio partitioner toothree noder som använder hello standardplacering aktören partition skulle distribueras thusly:</span><span class="sxs-lookup"><span data-stu-id="dbf74-149">For example, an actor service with nine partitions deployed toothree nodes using hello default actor partition placement would be distributed thusly:</span></span>

![Tillförlitliga aktörer distribution][2]

<span data-ttu-id="dbf74-151">hello aktören Framework hanterar schema och nyckeln intervallet partitionsinställningar för dig.</span><span class="sxs-lookup"><span data-stu-id="dbf74-151">hello Actor Framework manages partition scheme and key range settings for you.</span></span> <span data-ttu-id="dbf74-152">Detta förenklar vissa alternativ men har viss planering:</span><span class="sxs-lookup"><span data-stu-id="dbf74-152">This simplifies some choices but also carries some consideration:</span></span>

* <span data-ttu-id="dbf74-153">Reliable Services kan du toochoose en partitioneringsschema viktiga intervallet (när du använder ett intervall som partitioneringsschema) och partition count.</span><span class="sxs-lookup"><span data-stu-id="dbf74-153">Reliable Services allows you toochoose a partitioning scheme, key range (when using a range partitioning scheme), and partition count.</span></span> <span data-ttu-id="dbf74-154">Reliable Actors kräver att du använder hello Int64 viktiga komplett är begränsad toohello intervallet partitioneringsschema (hello uniform Int64 schemat).</span><span class="sxs-lookup"><span data-stu-id="dbf74-154">Reliable Actors is restricted toohello range partitioning scheme (hello uniform Int64 scheme) and requires you use hello full Int64 key range.</span></span>
* <span data-ttu-id="dbf74-155">Som standard placeras slumpmässigt aktörer partitioner, vilket resulterar i jämn fördelning.</span><span class="sxs-lookup"><span data-stu-id="dbf74-155">By default, actors are randomly placed into partitions resulting in uniform distribution.</span></span>
* <span data-ttu-id="dbf74-156">Eftersom aktörer placeras slumpmässigt, bör det förväntas att aktören operations alltid kommer att kräva nätverkskommunikation, inklusive serialisering och deserialisering av metoden anropsdata, medför latens och kostnader.</span><span class="sxs-lookup"><span data-stu-id="dbf74-156">Because actors are randomly placed, it should be expected that actor operations will always require network communication, including serialization and deserialization of method call data, incurring latency and overhead.</span></span>
* <span data-ttu-id="dbf74-157">I avancerade scenarier är möjliga toocontrol aktören partition placering med hjälp av Int64 aktören ID: N som mappar toospecific partitioner.</span><span class="sxs-lookup"><span data-stu-id="dbf74-157">In advanced scenarios, it is possible toocontrol actor partition placement by using Int64 actor IDs that map toospecific partitions.</span></span> <span data-ttu-id="dbf74-158">Dock kan göra så resultera i ett Obalanserat fördelning av aktörer över partitioner.</span><span class="sxs-lookup"><span data-stu-id="dbf74-158">However, doing so can result in an unbalanced distribution of actors across partitions.</span></span>

<span data-ttu-id="dbf74-159">Mer information om hur aktörstjänster partitioneras finns för[partitionering begrepp för aktörer](service-fabric-reliable-actors-platform.md#service-fabric-partition-concepts-for-actors).</span><span class="sxs-lookup"><span data-stu-id="dbf74-159">For more information on how actor services are partitioned, refer too[partitioning concepts for actors](service-fabric-reliable-actors-platform.md#service-fabric-partition-concepts-for-actors).</span></span>

### <a name="actor-communication"></a><span data-ttu-id="dbf74-160">Aktören kommunikation</span><span class="sxs-lookup"><span data-stu-id="dbf74-160">Actor communication</span></span>
<span data-ttu-id="dbf74-161">Aktören interaktioner definieras i ett gränssnitt som delas av hello aktören som implementerar gränssnittet hello och hello-klient som hämtar en proxy tooan aktören via hello samma gränssnitt.</span><span class="sxs-lookup"><span data-stu-id="dbf74-161">Actor interactions are defined in an interface that is shared by hello actor that implements hello interface, and hello client that gets a proxy tooan actor via hello same interface.</span></span> <span data-ttu-id="dbf74-162">Eftersom det här gränssnittet är används tooinvoke aktören metoder asynkront, måste varje metod i hello gränssnitt vara åtgärdsreturnerande.</span><span class="sxs-lookup"><span data-stu-id="dbf74-162">Because this interface is used tooinvoke actor methods asynchronously, every method on hello interface must be Task-returning.</span></span>

<span data-ttu-id="dbf74-163">Anrop av metoden och deras svar slutligen ger nätverksbegäranden över hello klustret, så hello argument och hello resultattyper hello uppgifter som att de returnerar måste kunna serialiseras av hello-plattformen.</span><span class="sxs-lookup"><span data-stu-id="dbf74-163">Method invocations and their responses ultimately result in network requests across hello cluster, so hello arguments and hello result types of hello tasks that they return must be serializable by hello platform.</span></span> <span data-ttu-id="dbf74-164">I synnerhet de måste vara [data minimera serialiserbara](service-fabric-reliable-actors-notes-on-actor-type-serialization.md).</span><span class="sxs-lookup"><span data-stu-id="dbf74-164">In particular, they must be [data contract serializable](service-fabric-reliable-actors-notes-on-actor-type-serialization.md).</span></span>

#### <a name="hello-actor-proxy"></a><span data-ttu-id="dbf74-165">hello aktören proxy</span><span class="sxs-lookup"><span data-stu-id="dbf74-165">hello actor proxy</span></span>
<span data-ttu-id="dbf74-166">hello Reliable Actors klienten API ger kommunikation mellan en aktören-instans och en aktören-klient.</span><span class="sxs-lookup"><span data-stu-id="dbf74-166">hello Reliable Actors client API provides communication between an actor instance and an actor client.</span></span> <span data-ttu-id="dbf74-167">toocommunicate med en aktör en klient skapar ett aktören proxy-objekt som implementerar hello aktören gränssnittet.</span><span class="sxs-lookup"><span data-stu-id="dbf74-167">toocommunicate with an actor, a client creates an actor proxy object that implements hello actor interface.</span></span> <span data-ttu-id="dbf74-168">hello klienten kommunicerar med hello aktören genom att anropa metoder på hello proxy-objekt.</span><span class="sxs-lookup"><span data-stu-id="dbf74-168">hello client interacts with hello actor by invoking methods on hello proxy object.</span></span> <span data-ttu-id="dbf74-169">hello aktören proxy kan användas för kommunikation i klient – aktören och aktören – aktören.</span><span class="sxs-lookup"><span data-stu-id="dbf74-169">hello actor proxy can be used for client-to-actor and actor-to-actor communication.</span></span>

```csharp
// Create a randomly distributed actor ID
ActorId actorId = ActorId.CreateRandom();

// This only creates a proxy object, it does not activate an actor or invoke any methods yet.
IMyActor myActor = ActorProxy.Create<IMyActor>(actorId, new Uri("fabric:/MyApp/MyActorService"));

// This will invoke a method on hello actor. If an actor with hello given ID does not exist, it will be activated by this method call.
await myActor.DoWorkAsync();
```

```java
// Create actor ID with some name
ActorId actorId = new ActorId("Actor1");

// This only creates a proxy object, it does not activate an actor or invoke any methods yet.
MyActor myActor = ActorProxyBase.create(actorId, new URI("fabric:/MyApp/MyActorService"), MyActor.class);

// This will invoke a method on hello actor. If an actor with hello given ID does not exist, it will be activated by this method call.
myActor.DoWorkAsync().get();
```


<span data-ttu-id="dbf74-170">Observera att hello två typer av information som används toocreate hello aktören proxyobjekt är hello aktörs-ID och hello programnamn.</span><span class="sxs-lookup"><span data-stu-id="dbf74-170">Note that hello two pieces of information used toocreate hello actor proxy object are hello actor ID and hello application name.</span></span> <span data-ttu-id="dbf74-171">hello aktörs-ID identifierar hello aktören medan hello programnamn identifierar hello [Service Fabric application](service-fabric-reliable-actors-platform.md#application-model) där hello aktören har distribuerats.</span><span class="sxs-lookup"><span data-stu-id="dbf74-171">hello actor ID uniquely identifies hello actor, while hello application name identifies hello [Service Fabric application](service-fabric-reliable-actors-platform.md#application-model) where hello actor is deployed.</span></span>

<span data-ttu-id="dbf74-172">Hej `ActorProxy`(C#) / `ActorProxyBase`klass (Java) på klientsidan för hello utför hello nödvändiga upplösning toolocate hello aktören-ID: t och öppna en kommunikationskanal till den.</span><span class="sxs-lookup"><span data-stu-id="dbf74-172">hello `ActorProxy`(C#) / `ActorProxyBase`(Java) class on hello client side performs hello necessary resolution toolocate hello actor by ID and open a communication channel with it.</span></span> <span data-ttu-id="dbf74-173">Den försöker också toolocate hello aktören hello gäller kommunikationsfel och växling vid fel.</span><span class="sxs-lookup"><span data-stu-id="dbf74-173">It also retries toolocate hello actor in hello cases of communication failures and failovers.</span></span> <span data-ttu-id="dbf74-174">Därför har meddelandeleverans hello följande egenskaper:</span><span class="sxs-lookup"><span data-stu-id="dbf74-174">As a result, message delivery has hello following characteristics:</span></span>

* <span data-ttu-id="dbf74-175">Meddelandeleverans är bästa prestanda.</span><span class="sxs-lookup"><span data-stu-id="dbf74-175">Message delivery is best effort.</span></span>
* <span data-ttu-id="dbf74-176">Aktörer får dubbla meddelanden från hello samma klient.</span><span class="sxs-lookup"><span data-stu-id="dbf74-176">Actors may receive duplicate messages from hello same client.</span></span>

### <a name="concurrency"></a><span data-ttu-id="dbf74-177">Samtidighet</span><span class="sxs-lookup"><span data-stu-id="dbf74-177">Concurrency</span></span>
<span data-ttu-id="dbf74-178">hello Reliable Actors runtime ger en enkel bygger åtkomst-modell för att komma åt aktören metoder.</span><span class="sxs-lookup"><span data-stu-id="dbf74-178">hello Reliable Actors runtime provides a simple turn-based access model for accessing actor methods.</span></span> <span data-ttu-id="dbf74-179">Det innebär att mer än en tråd kan vara aktiva i objektets aktören kod när som helst.</span><span class="sxs-lookup"><span data-stu-id="dbf74-179">This means that no more than one thread can be active inside an actor object's code at any time.</span></span> <span data-ttu-id="dbf74-180">Stäng-baserad åtkomst förenklar samtidiga system som det ingen behövs synkroniseringsmekanismer för dataåtkomst.</span><span class="sxs-lookup"><span data-stu-id="dbf74-180">Turn-based access greatly simplifies concurrent systems as there is no need for synchronization mechanisms for data access.</span></span> <span data-ttu-id="dbf74-181">Det innebär också måste vara konstruerade med speciella överväganden vid hello Enkeltrådig åtkomst natur för varje aktören-instans.</span><span class="sxs-lookup"><span data-stu-id="dbf74-181">It also means systems must be designed with special considerations for hello single-threaded access nature of each actor instance.</span></span>

* <span data-ttu-id="dbf74-182">En enda aktören-instans kan inte bearbeta fler än en begäran i taget.</span><span class="sxs-lookup"><span data-stu-id="dbf74-182">A single actor instance cannot process more than one request at a time.</span></span> <span data-ttu-id="dbf74-183">En instans av aktören kan orsaka en flaskhals för genomströmning om är det förväntade toohandle samtidiga begäranden.</span><span class="sxs-lookup"><span data-stu-id="dbf74-183">An actor instance can cause a throughput bottleneck if it is expected toohandle concurrent requests.</span></span>
* <span data-ttu-id="dbf74-184">Aktörer kan låsas i varandra om det finns en cirkulär begäran mellan två aktörer medan en extern begäran görs tooone hello aktörer samtidigt.</span><span class="sxs-lookup"><span data-stu-id="dbf74-184">Actors can deadlock on each other if there is a circular request between two actors while an external request is made tooone of hello actors simultaneously.</span></span> <span data-ttu-id="dbf74-185">hello aktören runtime kommer automatiskt tid ut på aktören anropar och utlösa ett undantag toohello anroparen toointerrupt möjligt deadlock situationer.</span><span class="sxs-lookup"><span data-stu-id="dbf74-185">hello actor runtime will automatically time out on actor calls and throw an exception toohello caller toointerrupt possible deadlock situations.</span></span>

![Tillförlitlig aktörer kommunikation][3]

#### <a name="turn-based-access"></a><span data-ttu-id="dbf74-187">Stäng-baserad åtkomst</span><span class="sxs-lookup"><span data-stu-id="dbf74-187">Turn-based access</span></span>
<span data-ttu-id="dbf74-188">En tur består av hello fullständig körningen av en aktören metod i svaret tooa begäran från andra aktörer eller klienter eller hello fullständig körningen av en [timer/påminnelse](service-fabric-reliable-actors-timers-reminders.md) återanrop.</span><span class="sxs-lookup"><span data-stu-id="dbf74-188">A turn consists of hello complete execution of an actor method in response tooa request from other actors or clients, or hello complete execution of a [timer/reminder](service-fabric-reliable-actors-timers-reminders.md) callback.</span></span> <span data-ttu-id="dbf74-189">Även om dessa metoder och återanrop asynkrona, interleave dem inte av hello aktörer runtime.</span><span class="sxs-lookup"><span data-stu-id="dbf74-189">Even though these methods and callbacks are asynchronous, hello Actors runtime does not interleave them.</span></span> <span data-ttu-id="dbf74-190">En Stäng måste vara helt färdiga innan en ny Stäng tillåts.</span><span class="sxs-lookup"><span data-stu-id="dbf74-190">A turn must be fully finished before a new turn is allowed.</span></span> <span data-ttu-id="dbf74-191">Med andra ord ett aktören metod eller timer/påminnelse motanrop som körs för tillfället måste vara helt färdiga innan en ny anropet tooa metod eller återanrop tillåts.</span><span class="sxs-lookup"><span data-stu-id="dbf74-191">In other words, an actor method or timer/reminder callback that is currently executing must be fully finished before a new call tooa method or callback is allowed.</span></span> <span data-ttu-id="dbf74-192">En metod eller ett återanrop anses toohave klar om hello körningen har returnerats från hello-metoden eller motringning och hello aktiviteten som returneras av metoden hello eller återanrop har slutförts.</span><span class="sxs-lookup"><span data-stu-id="dbf74-192">A method or callback is considered toohave finished if hello execution has returned from hello method or callback and hello task returned by hello method or callback has finished.</span></span> <span data-ttu-id="dbf74-193">Det är värt som betonar som bygger samtidighet följs även över olika metoder och timers återanrop.</span><span class="sxs-lookup"><span data-stu-id="dbf74-193">It is worth emphasizing that turn-based concurrency is respected even across different methods, timers, and callbacks.</span></span>

<span data-ttu-id="dbf74-194">hello aktörer runtime tvingar bygger samtidighet genom att skaffa ett lås per aktör hello början av en tur och släppa hello Lås hello slutet av hello aktivera.</span><span class="sxs-lookup"><span data-stu-id="dbf74-194">hello Actors runtime enforces turn-based concurrency by acquiring a per-actor lock at hello beginning of a turn and releasing hello lock at hello end of hello turn.</span></span> <span data-ttu-id="dbf74-195">Därför tillämpas bygger samtidighet på grundval av per aktör och inte över aktörer.</span><span class="sxs-lookup"><span data-stu-id="dbf74-195">Thus, turn-based concurrency is enforced on a per-actor basis and not across actors.</span></span> <span data-ttu-id="dbf74-196">Aktören metoder och timer/påminnelse återanrop kan köra samtidigt för olika aktörer.</span><span class="sxs-lookup"><span data-stu-id="dbf74-196">Actor methods and timer/reminder callbacks can execute simultaneously on behalf of different actors.</span></span>

<span data-ttu-id="dbf74-197">hello följande exempel illustrerar hello ovan begrepp.</span><span class="sxs-lookup"><span data-stu-id="dbf74-197">hello following example illustrates hello above concepts.</span></span> <span data-ttu-id="dbf74-198">Överväg ett aktörstyp som implementerar två asynkrona metoder (exempelvis *metod1* och *metod2*), en timer och en påminnelse.</span><span class="sxs-lookup"><span data-stu-id="dbf74-198">Consider an actor type that implements two asynchronous methods (say, *Method1* and *Method2*), a timer, and a reminder.</span></span> <span data-ttu-id="dbf74-199">hello diagrammet nedan visar ett exempel på en tidslinje för hello körning av dessa metoder och återanrop för två aktörer (*ActorId1* och *ActorId2*) som tillhör toothis aktören typen.</span><span class="sxs-lookup"><span data-stu-id="dbf74-199">hello diagram below shows an example of a timeline for hello execution of these methods and callbacks on behalf of two actors (*ActorId1* and *ActorId2*) that belong toothis actor type.</span></span>

![Tillförlitliga aktörer runtime bygger samtidighet och åtkomst][1]

<span data-ttu-id="dbf74-201">Det här diagrammet följer dessa regler:</span><span class="sxs-lookup"><span data-stu-id="dbf74-201">This diagram follows these conventions:</span></span>

* <span data-ttu-id="dbf74-202">Varje lodrät linje visar hello logiska flödet för körning av en metod eller ett återanrop för en viss aktören.</span><span class="sxs-lookup"><span data-stu-id="dbf74-202">Each vertical line shows hello logical flow of execution of a method or a callback on behalf of a particular actor.</span></span>
* <span data-ttu-id="dbf74-203">hello händelser markerats på varje lodrät linje i kronologisk ordning med nyare händelser som inträffar under äldre filer.</span><span class="sxs-lookup"><span data-stu-id="dbf74-203">hello events marked on each vertical line occur in chronological order, with newer events occurring below older ones.</span></span>
* <span data-ttu-id="dbf74-204">Olika färger används för tidslinjer motsvarande toodifferent aktörer.</span><span class="sxs-lookup"><span data-stu-id="dbf74-204">Different colors are used for timelines corresponding toodifferent actors.</span></span>
* <span data-ttu-id="dbf74-205">Markeringen är används tooindicate hello varaktighet för vilka hello lås per aktör utförs åt en metod eller ett återanrop.</span><span class="sxs-lookup"><span data-stu-id="dbf74-205">Highlighting is used tooindicate hello duration for which hello per-actor lock is held on behalf of a method or callback.</span></span>

<span data-ttu-id="dbf74-206">Några viktiga punkter tooconsider:</span><span class="sxs-lookup"><span data-stu-id="dbf74-206">Some important points tooconsider:</span></span>

* <span data-ttu-id="dbf74-207">Medan *metod1* körs på uppdrag av *ActorId2* i svaret tooclient begäran *xyz789*, en annan klientbegäran (*abc123*) anländer som kräver också *metod1* toobe som körs av *ActorId2*.</span><span class="sxs-lookup"><span data-stu-id="dbf74-207">While *Method1* is executing on behalf of *ActorId2* in response tooclient request *xyz789*, another client request (*abc123*) arrives that also requires *Method1* toobe executed by *ActorId2*.</span></span> <span data-ttu-id="dbf74-208">Dock hello andra körningen av *metod1* börjar inte förrän hello tidigare körningen har slutförts.</span><span class="sxs-lookup"><span data-stu-id="dbf74-208">However, hello second execution of *Method1* does not begin until hello prior execution has finished.</span></span> <span data-ttu-id="dbf74-209">På samma sätt kan en påminnelse registreras av *ActorId2* utlöses när *metod1* som körs i svaret tooclient begäran *xyz789*.</span><span class="sxs-lookup"><span data-stu-id="dbf74-209">Similarly, a reminder registered by *ActorId2* fires while *Method1* is being executed in response tooclient request *xyz789*.</span></span> <span data-ttu-id="dbf74-210">hello påminnelse återanrop körs förrän både körningar av *metod1* har slutförts.</span><span class="sxs-lookup"><span data-stu-id="dbf74-210">hello reminder callback is executed only after both executions of *Method1* are complete.</span></span> <span data-ttu-id="dbf74-211">Allt detta är på grund av tooturn-baserade samtidighet som tillämpas för *ActorId2*.</span><span class="sxs-lookup"><span data-stu-id="dbf74-211">All of this is due tooturn-based concurrency being enforced for *ActorId2*.</span></span>
* <span data-ttu-id="dbf74-212">På samma sätt tillämpas även bygger samtidighet för *ActorId1*, vilket framgår av hello körningen av *metod1*, *metod2*, och hello timer återanrop för *ActorId1* som händer i ett seriella sätt.</span><span class="sxs-lookup"><span data-stu-id="dbf74-212">Similarly, turn-based concurrency is also enforced for *ActorId1*, as demonstrated by hello execution of *Method1*, *Method2*, and hello timer callback on behalf of *ActorId1* happening in a serial fashion.</span></span>
* <span data-ttu-id="dbf74-213">Körningen av *metod1* för *ActorId1* överlappar körningen för *ActorId2*.</span><span class="sxs-lookup"><span data-stu-id="dbf74-213">Execution of *Method1* on behalf of *ActorId1* overlaps with its execution on behalf of *ActorId2*.</span></span> <span data-ttu-id="dbf74-214">Det beror på att bygger samtidighet tillämpas endast inom en aktör och inte över aktörer.</span><span class="sxs-lookup"><span data-stu-id="dbf74-214">This is because turn-based concurrency is enforced only within an actor and not across actors.</span></span>
* <span data-ttu-id="dbf74-215">I vissa hello metoden/återanrop körningar hello `Task`(C#) / `CompletableFuture`(Java) returnerades av hello metoden/återanrop slutförs efter hello-metoden returnerar.</span><span class="sxs-lookup"><span data-stu-id="dbf74-215">In some of hello method/callback executions, hello `Task`(C#) / `CompletableFuture`(Java) returned by hello method/callback finishes after hello method returns.</span></span> <span data-ttu-id="dbf74-216">I vissa andra har hello asynkron åtgärd redan gått ut av hello tid hello metoden/återanrop returnerar.</span><span class="sxs-lookup"><span data-stu-id="dbf74-216">In some others, hello asynchronous operation has already finished by hello time hello method/callback returns.</span></span> <span data-ttu-id="dbf74-217">I båda fallen släpps lås per aktör för hello endast när båda hello metoden/återanrop returnerar och hello asynkrona åtgärden har slutförts.</span><span class="sxs-lookup"><span data-stu-id="dbf74-217">In both cases, hello per-actor lock is released only after both hello method/callback returns and hello asynchronous operation finishes.</span></span>

#### <a name="reentrancy"></a><span data-ttu-id="dbf74-218">Återinträde</span><span class="sxs-lookup"><span data-stu-id="dbf74-218">Reentrancy</span></span>
<span data-ttu-id="dbf74-219">hello aktörer körning kan återinträde som standard.</span><span class="sxs-lookup"><span data-stu-id="dbf74-219">hello Actors runtime allows reentrancy by default.</span></span> <span data-ttu-id="dbf74-220">Det innebär att om en aktörsmetod av *aktören A* anropar en metod i *aktören B*, som i sin tur anropar en annan metod på *aktören A*,-metoden tillåts toorun.</span><span class="sxs-lookup"><span data-stu-id="dbf74-220">This means that if an actor method of *Actor A* calls a method on *Actor B*, which in turn calls another method on *Actor A*, that method is allowed toorun.</span></span> <span data-ttu-id="dbf74-221">Detta beror på att den är del av hello samma logiska anrop-kedjan kontext.</span><span class="sxs-lookup"><span data-stu-id="dbf74-221">This is because it is part of hello same logical call-chain context.</span></span> <span data-ttu-id="dbf74-222">Alla timer- och påminnelse anrop starta med hello nya logiska anropet kontext.</span><span class="sxs-lookup"><span data-stu-id="dbf74-222">All timer and reminder calls start with hello new logical call context.</span></span> <span data-ttu-id="dbf74-223">Se hello [Reliable Actors återinträde](service-fabric-reliable-actors-reentrancy.md) för mer information.</span><span class="sxs-lookup"><span data-stu-id="dbf74-223">See hello [Reliable Actors reentrancy](service-fabric-reliable-actors-reentrancy.md) for more details.</span></span>

#### <a name="scope-of-concurrency-guarantees"></a><span data-ttu-id="dbf74-224">Omfattning samtidighet garantier</span><span class="sxs-lookup"><span data-stu-id="dbf74-224">Scope of concurrency guarantees</span></span>
<span data-ttu-id="dbf74-225">hello aktörer runtime tillhandahåller dessa samtidighet garantier i situationer där den styr hello anrop av metoderna.</span><span class="sxs-lookup"><span data-stu-id="dbf74-225">hello Actors runtime provides these concurrency guarantees in situations where it controls hello invocation of these methods.</span></span> <span data-ttu-id="dbf74-226">Till exempel ger dessa garantier för hello metoden anrop som görs i svaret tooa klientbegäran samt timer och påminnelser.</span><span class="sxs-lookup"><span data-stu-id="dbf74-226">For example, it provides these guarantees for hello method invocations that are done in response tooa client request, as well as for timer and reminder callbacks.</span></span> <span data-ttu-id="dbf74-227">Men om hello aktören koden anropar direkt metoderna utanför hello-metoder som tillhandahålls av hello aktörer runtime, går inte att hello runtime ange samtidighet garantier.</span><span class="sxs-lookup"><span data-stu-id="dbf74-227">However, if hello actor code directly invokes these methods outside of hello mechanisms provided by hello Actors runtime, then hello runtime cannot provide any concurrency guarantees.</span></span> <span data-ttu-id="dbf74-228">Till exempel om hello-metoden har anropats hello kontexten för en uppgift som inte är associerad med hello aktiviteten som returneras av hello aktören metoder går inte att hello runtime ange samtidighet garantier.</span><span class="sxs-lookup"><span data-stu-id="dbf74-228">For example, if hello method is invoked in hello context of some task that is not associated with hello task returned by hello actor methods, then hello runtime cannot provide concurrency guarantees.</span></span> <span data-ttu-id="dbf74-229">Om hello-metoden anropas från en tråd som hello aktören skapar själv och sedan hello runtime kan också ge samtidighet garantier.</span><span class="sxs-lookup"><span data-stu-id="dbf74-229">If hello method is invoked from a thread that hello actor creates on its own, then hello runtime also cannot provide concurrency guarantees.</span></span> <span data-ttu-id="dbf74-230">Tooperform bakgrundsåtgärder aktörer bör därför använda [aktören timers och aktören påminnelser](service-fabric-reliable-actors-timers-reminders.md) som respekterar bygger samtidighet.</span><span class="sxs-lookup"><span data-stu-id="dbf74-230">Therefore, tooperform background operations, actors should use [actor timers and actor reminders](service-fabric-reliable-actors-timers-reminders.md) that respect turn-based concurrency.</span></span>

## <a name="next-steps"></a><span data-ttu-id="dbf74-231">Nästa steg</span><span class="sxs-lookup"><span data-stu-id="dbf74-231">Next steps</span></span>
* <span data-ttu-id="dbf74-232">Kom igång genom att skapa din första Reliable Actors-tjänst:</span><span class="sxs-lookup"><span data-stu-id="dbf74-232">Get started by building your first Reliable Actors service:</span></span>
   * [<span data-ttu-id="dbf74-233">Komma igång med Reliable Actors på .NET</span><span class="sxs-lookup"><span data-stu-id="dbf74-233">Getting started with Reliable Actors on .NET</span></span>](service-fabric-reliable-actors-get-started.md)
   * [<span data-ttu-id="dbf74-234">Komma igång med Reliable Actors Java</span><span class="sxs-lookup"><span data-stu-id="dbf74-234">Getting started with Reliable Actors on Java</span></span>](service-fabric-reliable-actors-get-started-java.md)

<!--Image references-->
[1]: ./media/service-fabric-reliable-actors-introduction/concurrency.png
[2]: ./media/service-fabric-reliable-actors-introduction/distribution.png
[3]: ./media/service-fabric-reliable-actors-introduction/actor-communication.png
