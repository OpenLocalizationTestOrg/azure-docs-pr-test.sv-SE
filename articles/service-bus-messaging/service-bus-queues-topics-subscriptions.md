---
title: "Översikt över Azure Service Bus-meddelanden köer, ämnen och prenumerationer | Microsoft Docs"
description: "Översikt över Service Bus meddelandeentiteter."
services: service-bus-messaging
documentationcenter: na
author: sethmanheim
manager: timlt
editor: 
ms.assetid: a306ced4-74e9-47c6-990a-d9c47efa31d5
ms.service: service-bus-messaging
ms.devlang: na
ms.topic: article
ms.tgt_pltfrm: na
ms.workload: na
ms.date: 06/28/2017
ms.author: sethm
ms.openlocfilehash: 00f9f38fbae028486270053dedb4df580a3f1a44
ms.sourcegitcommit: 50e23e8d3b1148ae2d36dad3167936b4e52c8a23
ms.translationtype: MT
ms.contentlocale: sv-SE
ms.lasthandoff: 08/18/2017
---
# <a name="service-bus-queues-topics-and-subscriptions"></a><span data-ttu-id="fcac1-103">Service Bus-köer, -ämnen och -prenumerationer</span><span class="sxs-lookup"><span data-stu-id="fcac1-103">Service Bus queues, topics, and subscriptions</span></span>

<span data-ttu-id="fcac1-104">Microsoft Azure Service Bus stöder en uppsättning molnbaserade, meddelande indatavärdena mellanprogram teknologier, inklusive tillförlitliga message Queuing- och varaktig Publicera/prenumerera på meddelanden.</span><span class="sxs-lookup"><span data-stu-id="fcac1-104">Microsoft Azure Service Bus supports a set of cloud-based, message-oriented middleware technologies including reliable message queuing and durable publish/subscribe messaging.</span></span> <span data-ttu-id="fcac1-105">Dessa ”asynkrona” meddelandefunktioner kan betraktas som frikopplad meddelandefunktioner som har stöd för att publicera och prenumerera temporal Frikoppling och scenarier med hjälp av Service Bus-meddelanden fabric för belastningsutjämning.</span><span class="sxs-lookup"><span data-stu-id="fcac1-105">These "brokered" messaging capabilities can be thought of as decoupled messaging features that support publish-subscribe, temporal decoupling, and load balancing scenarios using the Service Bus messaging fabric.</span></span> <span data-ttu-id="fcac1-106">Frikopplad kommunikation har många fördelar: klienter och servrar kan till exempel ansluta efter behov och utföra åtgärder på ett asynkront sätt.</span><span class="sxs-lookup"><span data-stu-id="fcac1-106">Decoupled communication has many advantages; for example, clients and servers can connect as needed and perform their operations in an asynchronous fashion.</span></span>

<span data-ttu-id="fcac1-107">Meddelandeentiteter som utgör kärnan i meddelandefunktioner i Service Bus är köer, ämnen och prenumerationer och regler/en åtgärd.</span><span class="sxs-lookup"><span data-stu-id="fcac1-107">The messaging entities that form the core of the messaging capabilities in Service Bus are queues, topics and subscriptions, and rules/actions.</span></span>

## <a name="queues"></a><span data-ttu-id="fcac1-108">Köer</span><span class="sxs-lookup"><span data-stu-id="fcac1-108">Queues</span></span>

<span data-ttu-id="fcac1-109">Köer erbjuder *First In, först ut* (FIFO) meddelandeleverans till en eller flera konkurrerande konsumenter.</span><span class="sxs-lookup"><span data-stu-id="fcac1-109">Queues offer *First In, First Out* (FIFO) message delivery to one or more competing consumers.</span></span> <span data-ttu-id="fcac1-110">Det vill säga förväntas meddelanden vanligtvis tas emot och bearbetas av mottagarna i den ordning som de har lagts till i kön, och varje meddelande tas emot och bearbetas av bara en meddelandekonsument.</span><span class="sxs-lookup"><span data-stu-id="fcac1-110">That is, messages are typically expected to be received and processed by the receivers in the order in which they were added to the queue, and each message is received and processed by only one message consumer.</span></span> <span data-ttu-id="fcac1-111">En stor fördel med köer är att uppnå ”temporal Frikoppling” av programkomponenter.</span><span class="sxs-lookup"><span data-stu-id="fcac1-111">A key benefit of using queues is to achieve "temporal decoupling" of application components.</span></span> <span data-ttu-id="fcac1-112">Med andra ord behöver producenter (avsändare) och konsumenter (mottagare) inte skicka och ta emot meddelanden på samma gång, eftersom meddelanden lagras varaktigt i kön.</span><span class="sxs-lookup"><span data-stu-id="fcac1-112">In other words, the producers (senders) and consumers (receivers) do not have to be sending and receiving messages at the same time, because messages are stored durably in the queue.</span></span> <span data-ttu-id="fcac1-113">Dessutom behöver producenten inte vänta på svar från konsumenten för att kunna fortsätta bearbetningen och skicka meddelanden.</span><span class="sxs-lookup"><span data-stu-id="fcac1-113">Furthermore, the producer does not have to wait for a reply from the consumer in order to continue to process and send messages.</span></span>

<span data-ttu-id="fcac1-114">En relaterad fördel är ”belastningsutjämning”, vilket innebär att producenter och konsumenter att skicka och ta emot meddelanden med olika hastigheter.</span><span class="sxs-lookup"><span data-stu-id="fcac1-114">A related benefit is "load leveling," which enables producers and consumers to send and receive messages at different rates.</span></span> <span data-ttu-id="fcac1-115">I många program varierar systembelastningen med tiden. dock är den bearbetningstid som krävs för varje arbetsenhet vanligtvis är konstant.</span><span class="sxs-lookup"><span data-stu-id="fcac1-115">In many applications, the system load varies over time; however, the processing time required for each unit of work is typically constant.</span></span> <span data-ttu-id="fcac1-116">Medlingen mellan meddelandeproducenter och konsumenter med hjälp av en kö innebär att den konsumerande appen endast som ska etableras för att kunna hantera en genomsnittlig belastning i stället för belastning.</span><span class="sxs-lookup"><span data-stu-id="fcac1-116">Intermediating message producers and consumers with a queue means that the consuming application only has to be provisioned to be able to handle average load instead of peak load.</span></span> <span data-ttu-id="fcac1-117">Köns djup växer och dras samman allt eftersom den inkommande belastningen varierar.</span><span class="sxs-lookup"><span data-stu-id="fcac1-117">The depth of the queue grows and contracts as the incoming load varies.</span></span> <span data-ttu-id="fcac1-118">Detta sparar direkt pengar avseende mängden infrastruktur som krävs för att underhålla.</span><span class="sxs-lookup"><span data-stu-id="fcac1-118">This directly saves money with regard to the amount of infrastructure required to service the application load.</span></span> <span data-ttu-id="fcac1-119">När belastningen ökar kan fler arbetsprocesser läggas för att läsa från kön.</span><span class="sxs-lookup"><span data-stu-id="fcac1-119">As the load increases, more worker processes can be added to read from the queue.</span></span> <span data-ttu-id="fcac1-120">Varje meddelande bearbetas bara av en av arbetsprocesserna.</span><span class="sxs-lookup"><span data-stu-id="fcac1-120">Each message is processed by only one of the worker processes.</span></span> <span data-ttu-id="fcac1-121">Dessutom kan den här pull-baserade belastningsutjämning, för optimal användning av worker-datorer även om worker datorer skiljer sig åt vad gäller processorkraft, som de hämtar meddelanden med sina egna högsta hastighet.</span><span class="sxs-lookup"><span data-stu-id="fcac1-121">Furthermore, this pull-based load balancing allows for optimum use of the worker computers even if the worker computers differ with regard to processing power, as they will pull messages at their own maximum rate.</span></span> <span data-ttu-id="fcac1-122">Det här mönstret kallas ofta ”konkurrerande konsument”-mönster.</span><span class="sxs-lookup"><span data-stu-id="fcac1-122">This pattern is often termed the "competing consumer" pattern.</span></span>

<span data-ttu-id="fcac1-123">Med hjälp av köer till mellanliggande mellan meddelandeproducenter och konsumenter innehåller en inbyggd lösa kopplingar mellan komponenterna.</span><span class="sxs-lookup"><span data-stu-id="fcac1-123">Using queues to intermediate between message producers and consumers provides an inherent loose coupling between the components.</span></span> <span data-ttu-id="fcac1-124">Eftersom producenter och konsumenter inte är medvetna om varandra, kan en konsument uppgraderas utan någon inverkan på producenten.</span><span class="sxs-lookup"><span data-stu-id="fcac1-124">Because producers and consumers are not aware of each other, a consumer can be upgraded without having any effect on the producer.</span></span>

<span data-ttu-id="fcac1-125">Skapa en kö är en process med flera steg.</span><span class="sxs-lookup"><span data-stu-id="fcac1-125">Creating a queue is a multi-step process.</span></span> <span data-ttu-id="fcac1-126">Du kan utföra hanteringsåtgärder för Service Bus meddelandeentiteter (köer och ämnen) via den [Microsoft.ServiceBus.NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager#microsoft_servicebus_namespacemanager) -klassen, som har skapats genom att tillhandahålla basadressen för namnområdet för Service Bus och användarens autentiseringsuppgifter.</span><span class="sxs-lookup"><span data-stu-id="fcac1-126">You perform management operations for Service Bus messaging entities (both queues and topics) via the [Microsoft.ServiceBus.NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager#microsoft_servicebus_namespacemanager) class, which is constructed by supplying the base address of the Service Bus namespace and the user credentials.</span></span> <span data-ttu-id="fcac1-127">[NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager#microsoft_servicebus_namespacemanager) tillhandahåller metoder för att skapa, räkna upp och ta bort meddelandeentiteter.</span><span class="sxs-lookup"><span data-stu-id="fcac1-127">[NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager#microsoft_servicebus_namespacemanager) provides methods to create, enumerate and delete messaging entities.</span></span> <span data-ttu-id="fcac1-128">När du har skapat en [Microsoft.ServiceBus.TokenProvider](/dotnet/api/microsoft.servicebus.tokenprovider#microsoft_servicebus_tokenprovider) objekt från SAS-namn och nyckel och ett namnområde servicehantering objekt, kan du använda den [Microsoft.ServiceBus.NamespaceManager.CreateQueue](/dotnet/api/microsoft.servicebus.namespacemanager#Microsoft_ServiceBus_NamespaceManager_CreateQueue_System_String_)metod för att skapa kön.</span><span class="sxs-lookup"><span data-stu-id="fcac1-128">After creating a [Microsoft.ServiceBus.TokenProvider](/dotnet/api/microsoft.servicebus.tokenprovider#microsoft_servicebus_tokenprovider) object from the SAS name and key, and a service namespace management object, you can use the [Microsoft.ServiceBus.NamespaceManager.CreateQueue](/dotnet/api/microsoft.servicebus.namespacemanager#Microsoft_ServiceBus_NamespaceManager_CreateQueue_System_String_) method to create the queue.</span></span> <span data-ttu-id="fcac1-129">Exempel:</span><span class="sxs-lookup"><span data-stu-id="fcac1-129">For example:</span></span>

```csharp
// Create management credentials
TokenProvider credentials = TokenProvider.CreateSharedAccessSignatureTokenProvider(sasKeyName,sasKeyValue);
// Create namespace client
NamespaceManager namespaceClient = new NamespaceManager(ServiceBusEnvironment.CreateServiceUri("sb", ServiceNamespace, string.Empty), credentials);
```

<span data-ttu-id="fcac1-130">Du kan sedan skapa ett köobjekt och en meddelandefabrik med Service Bus-URI som argument.</span><span class="sxs-lookup"><span data-stu-id="fcac1-130">You can then create a queue object and a messaging factory with the Service Bus URI as an argument.</span></span> <span data-ttu-id="fcac1-131">Exempel:</span><span class="sxs-lookup"><span data-stu-id="fcac1-131">For example:</span></span>

```csharp
QueueDescription myQueue;
myQueue = namespaceClient.CreateQueue("TestQueue");
MessagingFactory factory = MessagingFactory.Create(ServiceBusEnvironment.CreateServiceUri("sb", ServiceNamespace, string.Empty), credentials); 
QueueClient myQueueClient = factory.CreateQueueClient("TestQueue");
```

<span data-ttu-id="fcac1-132">Du kan skicka meddelanden till kön.</span><span class="sxs-lookup"><span data-stu-id="fcac1-132">You can then send messages to the queue.</span></span> <span data-ttu-id="fcac1-133">Om du har en lista över asynkrona meddelanden som kallas exempelvis `MessageList`, visas den liknar följande:</span><span class="sxs-lookup"><span data-stu-id="fcac1-133">For example, if you have a list of brokered messages called `MessageList`, the code appears similar to the following:</span></span>

```csharp
for (int count = 0; count < 6; count++)
{
    var issue = MessageList[count];
    issue.Label = issue.Properties["IssueTitle"].ToString();
    myQueueClient.Send(issue);
}
```

<span data-ttu-id="fcac1-134">Du sedan ta emot meddelanden från kön på följande sätt:</span><span class="sxs-lookup"><span data-stu-id="fcac1-134">You then receive messages from the queue as follows:</span></span>

```csharp
while ((message = myQueueClient.Receive(new TimeSpan(hours: 0, minutes: 0, seconds: 5))) != null)
    {
        Console.WriteLine(string.Format("Message received: {0}, {1}, {2}", message.SequenceNumber, message.Label, message.MessageId));
        message.Complete();

        Console.WriteLine("Processing message (sleeping...)");
        Thread.Sleep(1000);
    }
```

<span data-ttu-id="fcac1-135">I den [ReceiveAndDelete](/dotnet/api/microsoft.servicebus.messaging.receivemode) läge receive-åtgärden är en, det vill säga när Service Bus tar emot begäran, den markerar meddelandet som Förbrukat och skickar tillbaka det till programmet.</span><span class="sxs-lookup"><span data-stu-id="fcac1-135">In the [ReceiveAndDelete](/dotnet/api/microsoft.servicebus.messaging.receivemode) mode, the receive operation is single-shot; that is, when Service Bus receives the request, it marks the message as being consumed and returns it to the application.</span></span> <span data-ttu-id="fcac1-136">**ReceiveAndDelete** läge är den enklaste modellen och fungerar bäst för scenarier där programmet kan tolerera icke-bearbetning av ett meddelande om ett fel inträffar.</span><span class="sxs-lookup"><span data-stu-id="fcac1-136">**ReceiveAndDelete** mode is the simplest model and works best for scenarios in which the application can tolerate not processing a message in the event of a failure.</span></span> <span data-ttu-id="fcac1-137">För att förstå detta kan du föreställa dig ett scenario där konsumenten utfärdar en receive-begäran och sedan kraschar innan den kan bearbeta denna begäran.</span><span class="sxs-lookup"><span data-stu-id="fcac1-137">To understand this, consider a scenario in which the consumer issues the receive request and then crashes before processing it.</span></span> <span data-ttu-id="fcac1-138">Eftersom Service Bus markerar meddelandet som Förbrukat när programmet startas om och börjar förbruka meddelanden igen, kommer det ha missat meddelandet som förbrukades innan kraschen.</span><span class="sxs-lookup"><span data-stu-id="fcac1-138">Because Service Bus marks the message as being consumed, when the application restarts and begins consuming messages again, it will have missed the message that was consumed prior to the crash.</span></span>

<span data-ttu-id="fcac1-139">I [PeekLock](/dotnet/api/microsoft.servicebus.messaging.receivemode) läge receive-åtgärden blir två steg, vilket gör det möjligt att stödprogram som inte tolererar att ett meddelande saknas.</span><span class="sxs-lookup"><span data-stu-id="fcac1-139">In [PeekLock](/dotnet/api/microsoft.servicebus.messaging.receivemode) mode, the receive operation becomes two-stage, which makes it possible to support applications that cannot tolerate missing messages.</span></span> <span data-ttu-id="fcac1-140">När Service Bus tar emot begäran, den söker efter nästa meddelande som ska förbrukas, låser det för att förhindra att andra användare tar emot det och skickar sedan tillbaka det till programmet.</span><span class="sxs-lookup"><span data-stu-id="fcac1-140">When Service Bus receives the request, it finds the next message to be consumed, locks it to prevent other consumers from receiving it, and then returns it to the application.</span></span> <span data-ttu-id="fcac1-141">När programmet har avslutat bearbetningen av meddelandet (eller lagrar det på ett tillförlitligt sätt för framtida bearbetning), slutför programmet det andra steget i processen genom att anropa [Slutför](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Complete) för det mottagna meddelandet.</span><span class="sxs-lookup"><span data-stu-id="fcac1-141">After the application finishes processing the message (or stores it reliably for future processing), it completes the second stage of the receive process by calling [Complete](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Complete) on the received message.</span></span> <span data-ttu-id="fcac1-142">När Service Bus ser den **Slutför** anrop, markerar den meddelandet som Förbrukat.</span><span class="sxs-lookup"><span data-stu-id="fcac1-142">When Service Bus sees the **Complete** call, it marks the message as being consumed.</span></span>

<span data-ttu-id="fcac1-143">Om programmet inte kan bearbeta meddelandet av någon anledning, kan det anropa den [Avbryt](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Abandon) metod för det mottagna meddelandet (i stället för [Slutför](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Complete)).</span><span class="sxs-lookup"><span data-stu-id="fcac1-143">If the application is unable to process the message for some reason, it can call the [Abandon](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Abandon) method on the received message (instead of [Complete](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Complete)).</span></span> <span data-ttu-id="fcac1-144">Detta gör att Service Bus låser upp meddelandet och gör det tillgängligt att tas emot igen, antingen genom samma konsumenten eller av en annan konkurrerande konsument.</span><span class="sxs-lookup"><span data-stu-id="fcac1-144">This enables Service Bus to unlock the message and make it available to be received again, either by the same consumer or by another competing consumer.</span></span> <span data-ttu-id="fcac1-145">Det finns en tidsgräns som är kopplade till låset för det andra och om programmet misslyckas med att bearbeta meddelandet innan timeout för lås upphör att gälla (till exempel om programmet kraschar), kommer Service Bus låser upp meddelandet och gör det tillgängligt och kan tas emot igen ( i praktiken utför en [Avbryt](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Abandon) åtgärden som standard).</span><span class="sxs-lookup"><span data-stu-id="fcac1-145">Secondly, there is a timeout associated with the lock and if the application fails to process the message before the lock timeout expires (for example, if the application crashes), then Service Bus unlocks the message and makes it available to be received again (essentially performing an [Abandon](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Abandon) operation by default).</span></span>

<span data-ttu-id="fcac1-146">Observera att i händelse av att programmet kraschar efter att meddelandet har bearbetats men innan det **Slutför** begäran har utfärdats, meddelandet är levereras på nytt till programmet när den startas om.</span><span class="sxs-lookup"><span data-stu-id="fcac1-146">Note that in the event that the application crashes after processing the message, but before the **Complete** request is issued, the message is redelivered to the application when it restarts.</span></span> <span data-ttu-id="fcac1-147">Det här kallas ofta *minst när* bearbetning, det vill säga varje meddelande bearbetas minst en gång.</span><span class="sxs-lookup"><span data-stu-id="fcac1-147">This is often called *At Least Once* processing; that is, each message is processed at least once.</span></span> <span data-ttu-id="fcac1-148">I vissa situationer kan dock samma meddelande levereras.</span><span class="sxs-lookup"><span data-stu-id="fcac1-148">However, in certain situations the same message may be redelivered.</span></span> <span data-ttu-id="fcac1-149">Om scenariot inte tolererar duplicerad bearbetning och sedan ytterligare logik som krävs i programmet för att identifiera dubbletter som kan ske, baserat på de **MessageId** för meddelandet, som förblir konstant över leveransförsök.</span><span class="sxs-lookup"><span data-stu-id="fcac1-149">If the scenario cannot tolerate duplicate processing, then additional logic is required in the application to detect duplicates which can be achieved based upon the **MessageId** property of the message, which remains constant across delivery attempts.</span></span> <span data-ttu-id="fcac1-150">Detta kallas *exakt en gång* bearbetning.</span><span class="sxs-lookup"><span data-stu-id="fcac1-150">This is known as *Exactly Once* processing.</span></span>

## <a name="topics-and-subscriptions"></a><span data-ttu-id="fcac1-151">Ämnen och prenumerationer</span><span class="sxs-lookup"><span data-stu-id="fcac1-151">Topics and subscriptions</span></span>
<span data-ttu-id="fcac1-152">Till skillnad från köer, där varje meddelande bearbetas av en enskild konsument *avsnitt* och *prenumerationer* tillhandahålla en en-till-många-kommunikation i en *förPublicera/prenumerera* mönster.</span><span class="sxs-lookup"><span data-stu-id="fcac1-152">In contrast to queues, in which each message is processed by a single consumer, *topics* and *subscriptions* provide a one-to-many form of communication, in a *publish/subscribe* pattern.</span></span> <span data-ttu-id="fcac1-153">Användbar för att skala till ett stort antal mottagare, varje publicerat meddelande görs tillgänglig för varje prenumeration som har registrerats med ämnet.</span><span class="sxs-lookup"><span data-stu-id="fcac1-153">Useful for scaling to very large numbers of recipients, each published message is made available to each subscription registered with the topic.</span></span> <span data-ttu-id="fcac1-154">Meddelanden skickas till ett ämne och levereras till en eller flera associerade prenumerationer, beroende på filterregler som kan ställas in på grundval av per prenumeration.</span><span class="sxs-lookup"><span data-stu-id="fcac1-154">Messages are sent to a topic and delivered to one or more associated subscriptions, depending on filter rules that can be set on a per-subscription basis.</span></span> <span data-ttu-id="fcac1-155">Prenumerationerna kan använda ytterligare filter för att begränsa de meddelanden som de vill ha.</span><span class="sxs-lookup"><span data-stu-id="fcac1-155">The subscriptions can use additional filters to restrict the messages that they want to receive.</span></span> <span data-ttu-id="fcac1-156">Meddelanden skickas till ett ämne på samma sätt som de skickas till en kö, men meddelanden tas inte emot i artikeln direkt.</span><span class="sxs-lookup"><span data-stu-id="fcac1-156">Messages are sent to a topic in the same way they are sent to a queue, but messages are not received from the topic directly.</span></span> <span data-ttu-id="fcac1-157">I stället tas de emot från prenumerationer.</span><span class="sxs-lookup"><span data-stu-id="fcac1-157">Instead, they are received from subscriptions.</span></span> <span data-ttu-id="fcac1-158">En prenumeration på artikeln liknar en virtuell kö som tar emot kopior av meddelanden som skickas till ämnet.</span><span class="sxs-lookup"><span data-stu-id="fcac1-158">A topic subscription resembles a virtual queue that receives copies of the messages that are sent to the topic.</span></span> <span data-ttu-id="fcac1-159">Meddelanden tas emot från en prenumeration identiskt sätt som de tas emot från en kö.</span><span class="sxs-lookup"><span data-stu-id="fcac1-159">Messages are received from a subscription identically to the way they are received from a queue.</span></span>

<span data-ttu-id="fcac1-160">Som jämförelse sändning av meddelande-funktionerna i en kö mappar direkt till ett ämne och dess funktioner för message-mottagning mappar till en prenumeration.</span><span class="sxs-lookup"><span data-stu-id="fcac1-160">By way of comparison, the message-sending functionality of a queue maps directly to a topic and its message-receiving functionality maps to a subscription.</span></span> <span data-ttu-id="fcac1-161">Det innebär att prenumerationer stöder samma mönster som beskrivits tidigare i det här avsnittet avseende köer bland annat: konkurrerande konsument, temporal Frikoppling, utjämna belastningen och belastningsutjämning.</span><span class="sxs-lookup"><span data-stu-id="fcac1-161">Among other things, this means that subscriptions support the same patterns described earlier in this section with regard to queues: competing consumer, temporal decoupling, load leveling, and load balancing.</span></span>

<span data-ttu-id="fcac1-162">Skapa ett ämne liknar att skapa en kö som visas i exemplet i föregående avsnitt.</span><span class="sxs-lookup"><span data-stu-id="fcac1-162">Creating a topic is similar to creating a queue, as shown in the example in the previous section.</span></span> <span data-ttu-id="fcac1-163">Skapa URI-tjänsten och sedan använda den [NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager) klassen för att skapa namnområdet klient.</span><span class="sxs-lookup"><span data-stu-id="fcac1-163">Create the service URI, and then use the [NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager) class to create the namespace client.</span></span> <span data-ttu-id="fcac1-164">Du kan sedan skapa ett avsnitt som använder den [CreateTopic](/dotnet/api/microsoft.servicebus.namespacemanager#Microsoft_ServiceBus_NamespaceManager_CreateTopic_System_String_) metod.</span><span class="sxs-lookup"><span data-stu-id="fcac1-164">You can then create a topic using the [CreateTopic](/dotnet/api/microsoft.servicebus.namespacemanager#Microsoft_ServiceBus_NamespaceManager_CreateTopic_System_String_) method.</span></span> <span data-ttu-id="fcac1-165">Exempel:</span><span class="sxs-lookup"><span data-stu-id="fcac1-165">For example:</span></span>

```csharp
TopicDescription dataCollectionTopic = namespaceClient.CreateTopic("DataCollectionTopic");
```

<span data-ttu-id="fcac1-166">Lägg till prenumerationer som du vill:</span><span class="sxs-lookup"><span data-stu-id="fcac1-166">Next, add subscriptions as desired:</span></span>

```csharp
SubscriptionDescription myAgentSubscription = namespaceClient.CreateSubscription(myTopic.Path, "Inventory");
SubscriptionDescription myAuditSubscription = namespaceClient.CreateSubscription(myTopic.Path, "Dashboard");
```

<span data-ttu-id="fcac1-167">Du kan sedan skapa en klient i avsnittet.</span><span class="sxs-lookup"><span data-stu-id="fcac1-167">You can then create a topic client.</span></span> <span data-ttu-id="fcac1-168">Exempel:</span><span class="sxs-lookup"><span data-stu-id="fcac1-168">For example:</span></span>

```csharp
MessagingFactory factory = MessagingFactory.Create(serviceUri, tokenProvider);
TopicClient myTopicClient = factory.CreateTopicClient(myTopic.Path)
```

<span data-ttu-id="fcac1-169">Med hjälp av avsändaren kan du skicka och ta emot meddelanden till och från avsnittet som visas i föregående avsnitt.</span><span class="sxs-lookup"><span data-stu-id="fcac1-169">Using the message sender, you can send and receive messages to and from the topic, as shown in the previous section.</span></span> <span data-ttu-id="fcac1-170">Exempel:</span><span class="sxs-lookup"><span data-stu-id="fcac1-170">For example:</span></span>

```csharp
foreach (BrokeredMessage message in messageList)
{
    myTopicClient.Send(message);
    Console.WriteLine(
    string.Format("Message sent: Id = {0}, Body = {1}", message.MessageId, message.GetBody<string>()));
}
```

<span data-ttu-id="fcac1-171">Liknande köer, meddelanden tas emot från en prenumeration med hjälp av en [SubscriptionClient](/dotnet/api/microsoft.servicebus.messaging.subscriptionclient) objekt i stället för en [QueueClient](/dotnet/api/microsoft.servicebus.messaging.queueclient) objekt.</span><span class="sxs-lookup"><span data-stu-id="fcac1-171">Similar to queues, messages are received from a subscription using a [SubscriptionClient](/dotnet/api/microsoft.servicebus.messaging.subscriptionclient) object instead of a [QueueClient](/dotnet/api/microsoft.servicebus.messaging.queueclient) object.</span></span> <span data-ttu-id="fcac1-172">Skapa prenumeration klienten, skickar namnet på avsnittet, namnet på prenumerationen och (valfritt) receive-läge som parametrar.</span><span class="sxs-lookup"><span data-stu-id="fcac1-172">Create the subscription client, passing the name of the topic, the name of the subscription, and (optionally) the receive mode as parameters.</span></span> <span data-ttu-id="fcac1-173">Om till exempel den **inventering** prenumerationen:</span><span class="sxs-lookup"><span data-stu-id="fcac1-173">For example, with the **Inventory** subscription:</span></span>

```csharp
// Create the subscription client
MessagingFactory factory = MessagingFactory.Create(serviceUri, tokenProvider); 

SubscriptionClient agentSubscriptionClient = factory.CreateSubscriptionClient("IssueTrackingTopic", "Inventory", ReceiveMode.PeekLock);
SubscriptionClient auditSubscriptionClient = factory.CreateSubscriptionClient("IssueTrackingTopic", "Dashboard", ReceiveMode.ReceiveAndDelete); 

while ((message = agentSubscriptionClient.Receive(TimeSpan.FromSeconds(5))) != null)
{
    Console.WriteLine("\nReceiving message from Inventory...");
    Console.WriteLine(string.Format("Message received: Id = {0}, Body = {1}", message.MessageId, message.GetBody<string>()));
    message.Complete();
}          

// Create a receiver using ReceiveAndDelete mode
while ((message = auditSubscriptionClient.Receive(TimeSpan.FromSeconds(5))) != null)
{
    Console.WriteLine("\nReceiving message from Dashboard...");
    Console.WriteLine(string.Format("Message received: Id = {0}, Body = {1}", message.MessageId, message.GetBody<string>()));
}
```

### <a name="rules-and-actions"></a><span data-ttu-id="fcac1-174">Regler och åtgärder</span><span class="sxs-lookup"><span data-stu-id="fcac1-174">Rules and actions</span></span>
<span data-ttu-id="fcac1-175">I många fall är måste meddelanden som har specifika egenskaper bearbetas på olika sätt.</span><span class="sxs-lookup"><span data-stu-id="fcac1-175">In many scenarios, messages that have specific characteristics must be processed in different ways.</span></span> <span data-ttu-id="fcac1-176">För att möjliggöra detta, kan du konfigurera prenumerationer för att söka efter meddelanden som har önskade egenskaper och sedan göra vissa ändringar av dessa egenskaper.</span><span class="sxs-lookup"><span data-stu-id="fcac1-176">To enable this, you can configure subscriptions to find messages that have desired properties and then perform certain modifications to those properties.</span></span> <span data-ttu-id="fcac1-177">Du kan bara kopiera en delmängd av dessa meddelanden till prenumerationskön virtuella när Service Bus prenumerationer visas alla meddelanden som skickas till ämnet.</span><span class="sxs-lookup"><span data-stu-id="fcac1-177">While Service Bus subscriptions see all messages sent to the topic, you can only copy a subset of those messages to the virtual subscription queue.</span></span> <span data-ttu-id="fcac1-178">Detta åstadkoms med hjälp av prenumerationsfilter.</span><span class="sxs-lookup"><span data-stu-id="fcac1-178">This is accomplished using subscription filters.</span></span> <span data-ttu-id="fcac1-179">Sådana ändringar kallas *filtrera åtgärder*.</span><span class="sxs-lookup"><span data-stu-id="fcac1-179">Such modifications are called *filter actions*.</span></span> <span data-ttu-id="fcac1-180">När en prenumeration har skapats kan du ange ett filteruttryck som fungerar i egenskaperna för meddelandet, både systemegenskaperna (till exempel **etikett**) och anpassade egenskaper (till exempel  **StoreName**.) Filteruttrycket SQL är valfri i det här fallet; utan en SQL-filteruttrycket utförs något filter som definieras för en prenumeration på alla meddelanden för den prenumerationen.</span><span class="sxs-lookup"><span data-stu-id="fcac1-180">When a subscription is created, you can supply a filter expression that operates on the properties of the message, both the system properties (for example, **Label**) and custom application properties (for example, **StoreName**.) The SQL filter expression is optional in this case; without a SQL filter expression, any filter action defined on a subscription will be performed on all the messages for that subscription.</span></span>

<span data-ttu-id="fcac1-181">I föregående exempel, att filtrera meddelanden kommer endast från **Store1**, skulle du skapa instrumentpanelen prenumeration på följande sätt:</span><span class="sxs-lookup"><span data-stu-id="fcac1-181">Using the previous example, to filter messages coming only from **Store1**, you would create the Dashboard subscription as follows:</span></span>

```csharp
namespaceManager.CreateSubscription("IssueTrackingTopic", "Dashboard", new SqlFilter("StoreName = 'Store1'"));
```

<span data-ttu-id="fcac1-182">Med den här prenumerationsfiltret på plats, endast meddelanden som har den `StoreName` egenskapen `Store1` kopieras till en virtuell kö för den `Dashboard` prenumeration.</span><span class="sxs-lookup"><span data-stu-id="fcac1-182">With this subscription filter in place, only messages that have the `StoreName` property set to `Store1` are copied to the virtual queue for the `Dashboard` subscription.</span></span>

<span data-ttu-id="fcac1-183">Mer information om möjliga filtret värden finns i dokumentationen för den [SqlFilter](/dotnet/api/microsoft.servicebus.messaging.sqlfilter) och [SqlRuleAction](/dotnet/api/microsoft.servicebus.messaging.sqlruleaction) klasser.</span><span class="sxs-lookup"><span data-stu-id="fcac1-183">For more information about possible filter values, see the documentation for the [SqlFilter](/dotnet/api/microsoft.servicebus.messaging.sqlfilter) and [SqlRuleAction](/dotnet/api/microsoft.servicebus.messaging.sqlruleaction) classes.</span></span> <span data-ttu-id="fcac1-184">Se även den [asynkrona meddelanden: avancerade filter](http://code.msdn.microsoft.com/Brokered-Messaging-6b0d2749) och [avsnittet filter](https://github.com/Azure-Samples/azure-servicebus-messaging-samples/tree/master/TopicFilters) prover.</span><span class="sxs-lookup"><span data-stu-id="fcac1-184">Also, see the [Brokered Messaging: Advanced Filters](http://code.msdn.microsoft.com/Brokered-Messaging-6b0d2749) and [Topic Filters](https://github.com/Azure-Samples/azure-servicebus-messaging-samples/tree/master/TopicFilters) samples.</span></span>

## <a name="next-steps"></a><span data-ttu-id="fcac1-185">Nästa steg</span><span class="sxs-lookup"><span data-stu-id="fcac1-185">Next steps</span></span>
<span data-ttu-id="fcac1-186">Se följande avancerade avsnitt för mer information och exempel på hur du använder Service Bus-meddelanden.</span><span class="sxs-lookup"><span data-stu-id="fcac1-186">See the following advanced topics for more information and examples of using Service Bus messaging.</span></span>

* [<span data-ttu-id="fcac1-187">Översikt över Service Bus-meddelandetjänster</span><span class="sxs-lookup"><span data-stu-id="fcac1-187">Service Bus messaging overview</span></span>](service-bus-messaging-overview.md)
* [<span data-ttu-id="fcac1-188">Service Bus brokered messaging .NET tutorial</span><span class="sxs-lookup"><span data-stu-id="fcac1-188">Service Bus brokered messaging .NET tutorial</span></span>](service-bus-brokered-tutorial-dotnet.md)
* [<span data-ttu-id="fcac1-189">Service Bus självstudiekurs om asynkrona meddelanden REST</span><span class="sxs-lookup"><span data-stu-id="fcac1-189">Service Bus brokered messaging REST tutorial</span></span>](service-bus-brokered-tutorial-rest.md)
* [<span data-ttu-id="fcac1-190">Ämnesfilter</span><span class="sxs-lookup"><span data-stu-id="fcac1-190">Topic Filters sample </span></span>](https://github.com/Azure/azure-service-bus/tree/master/samples/DotNet/Microsoft.ServiceBus.Messaging/TopicFilters)
* [<span data-ttu-id="fcac1-191">Asynkrona meddelanden: Avancerade filter-exempel</span><span class="sxs-lookup"><span data-stu-id="fcac1-191">Brokered Messaging: Advanced Filters sample</span></span>](http://code.msdn.microsoft.com/Brokered-Messaging-6b0d2749)

