---
title: "Skriva program som använder Azure Service Bus-köer | Microsoft Docs"
description: "Hur du skriver en enkel kö-baserade program som använder Azure Service Bus."
services: service-bus-messaging
documentationcenter: na
author: sethmanheim
manager: timlt
editor: 
ms.assetid: 754d91b3-1426-405e-84b4-fd36d65b114a
ms.service: service-bus-messaging
ms.devlang: na
ms.topic: article
ms.tgt_pltfrm: na
ms.workload: na
ms.date: 08/07/2017
ms.author: sethm
ms.openlocfilehash: 419caff7e8ceeb419c89a2ef9a6614c1accf3e52
ms.sourcegitcommit: 50e23e8d3b1148ae2d36dad3167936b4e52c8a23
ms.translationtype: MT
ms.contentlocale: sv-SE
ms.lasthandoff: 08/18/2017
---
# <a name="create-applications-that-use-service-bus-queues"></a><span data-ttu-id="b34cf-103">Skapa appar som använder Service Bus-köer</span><span class="sxs-lookup"><span data-stu-id="b34cf-103">Create applications that use Service Bus queues</span></span>
<span data-ttu-id="b34cf-104">Det här avsnittet beskriver Service Bus-köer och visar hur du skriver en enkel kö-baserade program som använder Service Bus.</span><span class="sxs-lookup"><span data-stu-id="b34cf-104">This topic describes Service Bus queues and shows how to write a simple queue-based application that uses Service Bus.</span></span>

<span data-ttu-id="b34cf-105">Anta från hela världen för retail försäljningsdata från enskilda Point-of-Sale () Kassaterminaler som måste vidarebefordrar till ett lagersystem som använder data för att avgöra när börs måste fyllas.</span><span class="sxs-lookup"><span data-stu-id="b34cf-105">Consider a scenario from the world of retail in which sales data from individual Point-of-Sale (POS) terminals must be routed to an inventory management system that uses the data to determine when stock has to be replenished.</span></span> <span data-ttu-id="b34cf-106">Den här lösningen använder Service Bus-meddelanden för kommunikation mellan terminalerna och lagersystem, enligt beskrivningen i följande bild:</span><span class="sxs-lookup"><span data-stu-id="b34cf-106">This solution uses Service Bus messaging for the communication between the terminals and the inventory management system, as illustrated in the following figure:</span></span>

![Bild 1-Service Bus-köer](./media/service-bus-create-queues/IC657161.gif)

<span data-ttu-id="b34cf-108">Varje POS terminal rapporterar försäljning data genom att skicka meddelanden till den **DataCollectionQueue**.</span><span class="sxs-lookup"><span data-stu-id="b34cf-108">Each POS terminal reports its sales data by sending messages to the **DataCollectionQueue**.</span></span> <span data-ttu-id="b34cf-109">Dessa meddelanden ligger kvar i kön tills de har hämtats av hanteringssystem för inventering.</span><span class="sxs-lookup"><span data-stu-id="b34cf-109">These messages remain in this queue until they are retrieved by the inventory management system.</span></span> <span data-ttu-id="b34cf-110">Det här mönstret kallas ofta *asynkrona meddelanden*eftersom POS-terminal inte behöver vänta på svar från lagersystem fortsätta bearbetningen.</span><span class="sxs-lookup"><span data-stu-id="b34cf-110">This pattern is often termed *asynchronous messaging*, because the POS terminal does not have to wait for a reply from the inventory management system to continue processing.</span></span>

## <a name="why-queuing"></a><span data-ttu-id="b34cf-111">Varför queuing?</span><span class="sxs-lookup"><span data-stu-id="b34cf-111">Why queuing?</span></span>
<span data-ttu-id="b34cf-112">Innan vi titta på koden som krävs för att ställa in det här programmet, Överväg fördelarna med att använda en kö i det här scenariot i stället för att kassaterminalerna prata direkt (synkront) till hanteringssystemet inventering.</span><span class="sxs-lookup"><span data-stu-id="b34cf-112">Before we look at the code that is required to set up this application, consider the advantages of using a queue in this scenario instead of having the POS terminals talk directly (synchronously) to the inventory management system.</span></span>

### <a name="temporal-decoupling"></a><span data-ttu-id="b34cf-113">Tidsbestämd Frikoppling</span><span class="sxs-lookup"><span data-stu-id="b34cf-113">Temporal decoupling</span></span>
<span data-ttu-id="b34cf-114">Med mönstret för asynkrona meddelanden, behöver producenter och konsumenter inte vara online samtidigt.</span><span class="sxs-lookup"><span data-stu-id="b34cf-114">With the asynchronous messaging pattern, producers and consumers do not have to be online at the same time.</span></span> <span data-ttu-id="b34cf-115">Meddelandeinfrastrukturen lagrar meddelanden på ett tillförlitligt sätt tills konsumentparten är redo att ta emot dem.</span><span class="sxs-lookup"><span data-stu-id="b34cf-115">The messaging infrastructure reliably stores messages until the consuming party is ready to receive them.</span></span> <span data-ttu-id="b34cf-116">Detta innebär att komponenterna i den distribuerade appen kan frikopplas, antingen frivilligt; till exempel för underhåll, eller på grund av en komponentkrasch, utan påverkar hela systemet.</span><span class="sxs-lookup"><span data-stu-id="b34cf-116">This means the components of the distributed application can be disconnected, either voluntarily; for example, for maintenance, or due to a component crash, without affecting the whole system.</span></span> <span data-ttu-id="b34cf-117">Den konsumerande appen kan bara innehålla vara online under vissa tider på dagen.</span><span class="sxs-lookup"><span data-stu-id="b34cf-117">Furthermore, the consuming application may only have to be online during certain times of the day.</span></span> <span data-ttu-id="b34cf-118">Till exempel i detta scenario retail kanske hanteringssystemet inventering endast efter slutet av arbetsdagen.</span><span class="sxs-lookup"><span data-stu-id="b34cf-118">For example, in this retail scenario, the inventory management system may only have to come online after the end of the business day.</span></span>

### <a name="load-leveling"></a><span data-ttu-id="b34cf-119">Belastningsutjämning</span><span class="sxs-lookup"><span data-stu-id="b34cf-119">Load leveling</span></span>
<span data-ttu-id="b34cf-120">I många program varierar systembelastningen över tiden, medan den bearbetningstid som krävs för varje arbetsenhet är vanligtvis är konstant.</span><span class="sxs-lookup"><span data-stu-id="b34cf-120">In many applications system load varies over time, whereas the processing time required for each unit of work is typically constant.</span></span> <span data-ttu-id="b34cf-121">Medlingen mellan meddelandeproducenter och konsumenter med hjälp av en kö innebär att den konsumerande appen (arbetaren) endast måste etableras för att underhålla en genomsnittlig belastning i stället för en belastning.</span><span class="sxs-lookup"><span data-stu-id="b34cf-121">Intermediating message producers and consumers with a queue means that the consuming application (the worker) only has to be provisioned to service an average load rather than a peak load.</span></span> <span data-ttu-id="b34cf-122">Köns djup växer och kontrakt som den inkommande belastningen varierar.</span><span class="sxs-lookup"><span data-stu-id="b34cf-122">The depth of the queue will grow and contract as the incoming load varies.</span></span> <span data-ttu-id="b34cf-123">Detta sparar direkt pengar avseende mängden infrastruktur som krävs för att underhålla.</span><span class="sxs-lookup"><span data-stu-id="b34cf-123">This directly saves money with regard to the amount of infrastructure required to service the application load.</span></span>

![Service Bus-köer bild 2](./media/service-bus-create-queues/IC657162.gif)

### <a name="load-balancing"></a><span data-ttu-id="b34cf-125">Belastningsutjämning</span><span class="sxs-lookup"><span data-stu-id="b34cf-125">Load balancing</span></span>
<span data-ttu-id="b34cf-126">När belastningen ökar kan fler arbetsprocesser läggas för att läsa från kön worker.</span><span class="sxs-lookup"><span data-stu-id="b34cf-126">As the load increases, more worker processes can be added to read from the worker queue.</span></span> <span data-ttu-id="b34cf-127">Varje meddelande bearbetas bara av en av arbetsprocesserna.</span><span class="sxs-lookup"><span data-stu-id="b34cf-127">Each message is processed by only one of the worker processes.</span></span> <span data-ttu-id="b34cf-128">Dessutom kan den här pull-baserade belastningsutjämning, för optimal användning av worker-datorer även om worker datorer skiljer sig åt vad gäller processorkraft, som de hämtar meddelanden med sina egna högsta hastighet.</span><span class="sxs-lookup"><span data-stu-id="b34cf-128">Furthermore, this pull-based load balancing allows for optimum usage of the worker computers even if the worker computers differ with regard to processing power, as they will pull messages at their own maximum rate.</span></span> <span data-ttu-id="b34cf-129">Det här mönstret kallas ofta konkurrerande konsument mönstret.</span><span class="sxs-lookup"><span data-stu-id="b34cf-129">This pattern is often termed the competing consumer pattern.</span></span>

![Service Bus-köer bild 3](./media/service-bus-create-queues/IC657163.gif)

### <a name="loose-coupling"></a><span data-ttu-id="b34cf-131">Lösa kopplingar</span><span class="sxs-lookup"><span data-stu-id="b34cf-131">Loose coupling</span></span>
<span data-ttu-id="b34cf-132">Använda message queuing till mellanliggande mellan meddelandeproducenter och konsumenter innehåller en inbyggd lösa kopplingar mellan komponenterna.</span><span class="sxs-lookup"><span data-stu-id="b34cf-132">Using message queuing to intermediate between message producers and consumers provides an intrinsic loose coupling between the components.</span></span> <span data-ttu-id="b34cf-133">Eftersom producenter och konsumenter inte är medvetna om varandra, kan en konsument uppgraderas utan någon inverkan på producenten.</span><span class="sxs-lookup"><span data-stu-id="b34cf-133">Because producers and consumers are not aware of each other, a consumer can be upgraded without having any effect on the producer.</span></span> <span data-ttu-id="b34cf-134">Dessutom kan meddelanden topologin utvecklas utan att påverka befintliga slutpunkter.</span><span class="sxs-lookup"><span data-stu-id="b34cf-134">Furthermore, the messaging topology can evolve without affecting the existing endpoints.</span></span> <span data-ttu-id="b34cf-135">Kommer vi att diskutera detta mer när vi pratar om Publicera/prenumerera.</span><span class="sxs-lookup"><span data-stu-id="b34cf-135">We’ll discuss this more when we talk about publish/subscribe.</span></span>

## <a name="show-me-the-code"></a><span data-ttu-id="b34cf-136">Visa koden</span><span class="sxs-lookup"><span data-stu-id="b34cf-136">Show me the code</span></span>
<span data-ttu-id="b34cf-137">I följande avsnitt beskrivs hur du använder Service Bus för att skapa det här programmet.</span><span class="sxs-lookup"><span data-stu-id="b34cf-137">The following section shows how to use Service Bus to build this application.</span></span>

### <a name="sign-up-for-an-azure-account"></a><span data-ttu-id="b34cf-138">Registrera dig för ett Azure-konto</span><span class="sxs-lookup"><span data-stu-id="b34cf-138">Sign up for an Azure account</span></span>
<span data-ttu-id="b34cf-139">Du behöver ett Azure-konto för att börja arbeta med Service Bus.</span><span class="sxs-lookup"><span data-stu-id="b34cf-139">You’ll need an Azure account in order to start working with Service Bus.</span></span> <span data-ttu-id="b34cf-140">Om du inte redan har en, du kan registrera dig för ett kostnadsfritt konto [här](https://azure.microsoft.com/pricing/free-trial/?WT.mc_id=A85619ABF).</span><span class="sxs-lookup"><span data-stu-id="b34cf-140">If you do not already have one, you can sign up for a free account [here](https://azure.microsoft.com/pricing/free-trial/?WT.mc_id=A85619ABF).</span></span>

### <a name="create-a-namespace"></a><span data-ttu-id="b34cf-141">Skapa ett namnområde</span><span class="sxs-lookup"><span data-stu-id="b34cf-141">Create a namespace</span></span>
<span data-ttu-id="b34cf-142">När du har en prenumeration kan du [skapa ett namnområde för tjänsten](service-bus-create-namespace-portal.md).</span><span class="sxs-lookup"><span data-stu-id="b34cf-142">Once you have a subscription, you can [create a service namespace](service-bus-create-namespace-portal.md).</span></span> <span data-ttu-id="b34cf-143">Varje namnområde som fungerar som en omfattningsbehållare för en uppsättning Service Bus-entiteter.</span><span class="sxs-lookup"><span data-stu-id="b34cf-143">Each namespace acts as a scoping container for a set of Service Bus entities.</span></span> <span data-ttu-id="b34cf-144">Ge din nya namnområdet ett unikt namn för alla Service Bus-konton.</span><span class="sxs-lookup"><span data-stu-id="b34cf-144">Give your new namespace a unique name across all Service Bus accounts.</span></span> 

### <a name="install-the-nuget-package"></a><span data-ttu-id="b34cf-145">Installera NuGet-paketet</span><span class="sxs-lookup"><span data-stu-id="b34cf-145">Install the NuGet package</span></span>
<span data-ttu-id="b34cf-146">Om du vill använda Service Bus-namnrymd, måste ett program referera till Service Bus-sammansättningen specifikt Microsoft.ServiceBus.dll.</span><span class="sxs-lookup"><span data-stu-id="b34cf-146">To use the Service Bus namespace, an application must reference the Service Bus assembly, specifically Microsoft.ServiceBus.dll.</span></span> <span data-ttu-id="b34cf-147">Du hittar den här sammansättningen som en del av Microsoft Azure SDK och hämta är tillgänglig på den [hämtningssidan för Azure SDK](https://azure.microsoft.com/downloads/).</span><span class="sxs-lookup"><span data-stu-id="b34cf-147">You can find this assembly as part of the Microsoft Azure SDK, and the download is available at the [Azure SDK download page](https://azure.microsoft.com/downloads/).</span></span> <span data-ttu-id="b34cf-148">Men den [Service Bus NuGet-paketet](https://www.nuget.org/packages/WindowsAzure.ServiceBus) är det enklaste sättet att hämta Service Bus-API och att konfigurera ditt program med alla Service Bus-beroenden.</span><span class="sxs-lookup"><span data-stu-id="b34cf-148">However, the [Service Bus NuGet package](https://www.nuget.org/packages/WindowsAzure.ServiceBus) is the easiest way to get the Service Bus API and to configure your application with all of the Service Bus dependencies.</span></span>

### <a name="create-the-queue"></a><span data-ttu-id="b34cf-149">Skapa kön</span><span class="sxs-lookup"><span data-stu-id="b34cf-149">Create the queue</span></span>
<span data-ttu-id="b34cf-150">Hanteringsåtgärder för Service Bus meddelandeentiteter (köer och publicera/prenumerera avsnitt) utförs via den [NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager) klass.</span><span class="sxs-lookup"><span data-stu-id="b34cf-150">Management operations for Service Bus messaging entities (queues and publish/subscribe topics) are performed via the [NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager) class.</span></span> <span data-ttu-id="b34cf-151">Service Bus använder en [delade signatur åtkomst (SAS)](service-bus-sas.md) baserat säkerhetsmodell.</span><span class="sxs-lookup"><span data-stu-id="b34cf-151">Service Bus uses a [Shared Access Signature (SAS)](service-bus-sas.md) based security model.</span></span> <span data-ttu-id="b34cf-152">Den [TokenProvider](/dotnet/api/microsoft.servicebus.tokenprovider) klassen representerar en leverantör av säkerhetstoken med inbyggda fabriksmetoder som returnerar vissa välkända tokenleverantörer.</span><span class="sxs-lookup"><span data-stu-id="b34cf-152">The [TokenProvider](/dotnet/api/microsoft.servicebus.tokenprovider) class represents a security token provider with built-in factory methods returning some well-known token providers.</span></span> <span data-ttu-id="b34cf-153">Vi använder en [CreateSharedAccessSignatureTokenProvider](/dotnet/api/microsoft.servicebus.tokenprovider#Microsoft_ServiceBus_TokenProvider_CreateSharedAccessSignatureTokenProvider_System_String_) metod för att rymma SAS-autentiseringsuppgifter.</span><span class="sxs-lookup"><span data-stu-id="b34cf-153">We’ll use a [CreateSharedAccessSignatureTokenProvider](/dotnet/api/microsoft.servicebus.tokenprovider#Microsoft_ServiceBus_TokenProvider_CreateSharedAccessSignatureTokenProvider_System_String_) method to hold the SAS credentials.</span></span> <span data-ttu-id="b34cf-154">Den [NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager) instans sedan konstruerade med basadressen för namnområdet för Service Bus och tokenleverantör.</span><span class="sxs-lookup"><span data-stu-id="b34cf-154">The [NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager) instance is then constructed with the base address of the Service Bus namespace and the token provider.</span></span>

<span data-ttu-id="b34cf-155">Den [NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager) klassen innehåller metoder för att skapa, räkna upp och ta bort meddelandeentiteter.</span><span class="sxs-lookup"><span data-stu-id="b34cf-155">The [NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager) class provides methods to create, enumerate and delete messaging entities.</span></span> <span data-ttu-id="b34cf-156">Koden som visas här visas hur [NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager) instans skapas och används för att skapa den **DataCollectionQueue** kön.</span><span class="sxs-lookup"><span data-stu-id="b34cf-156">The code that is shown here shows how the [NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager) instance is created and used to create the **DataCollectionQueue** queue.</span></span>

```csharp
Uri uri = ServiceBusEnvironment.CreateServiceUri("sb", 
                "test-blog", string.Empty);
string name = "RootManageSharedAccessKey";
string key = "abcdefghijklmopqrstuvwxyz";

TokenProvider tokenProvider = 
    TokenProvider.CreateSharedAccessSignatureTokenProvider(name, key);
NamespaceManager namespaceManager = 
    new NamespaceManager(uri, tokenProvider);
namespaceManager.CreateQueue("DataCollectionQueue");
```

<span data-ttu-id="b34cf-157">Observera att det finns overloads av den [CreateQueue](/dotnet/api/microsoft.servicebus.namespacemanager#Microsoft_ServiceBus_NamespaceManager_CreateQueue_System_String_) metoden som gör att egenskaper för kön till finjusteras.</span><span class="sxs-lookup"><span data-stu-id="b34cf-157">Note that there are overloads of the [CreateQueue](/dotnet/api/microsoft.servicebus.namespacemanager#Microsoft_ServiceBus_NamespaceManager_CreateQueue_System_String_) method that enable properties of the queue to be tuned.</span></span> <span data-ttu-id="b34cf-158">Du kan till exempel ange time to live (TTL) Standardvärdet för meddelanden som skickas till kön.</span><span class="sxs-lookup"><span data-stu-id="b34cf-158">For example, you can set the default time-to-live (TTL) value for messages sent to the queue.</span></span>

### <a name="send-messages-to-the-queue"></a><span data-ttu-id="b34cf-159">Skicka meddelanden till kön</span><span class="sxs-lookup"><span data-stu-id="b34cf-159">Send messages to the queue</span></span>
<span data-ttu-id="b34cf-160">För körning åtgärder på Service Bus-enheter. till exempel skicka och ta emot meddelanden, ett program måste först skapa en [MessagingFactory](/dotnet/api/microsoft.servicebus.messaging.messagingfactory) objekt.</span><span class="sxs-lookup"><span data-stu-id="b34cf-160">For run-time operations on Service Bus entities; for example, sending and receiving messages, an application must first create a [MessagingFactory](/dotnet/api/microsoft.servicebus.messaging.messagingfactory) object.</span></span> <span data-ttu-id="b34cf-161">Liknar den [NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager) klassen, de [MessagingFactory](/dotnet/api/microsoft.servicebus.messaging.messagingfactory) instans skapas från basadressen för namnområdet för tjänsten och tokenleverantör.</span><span class="sxs-lookup"><span data-stu-id="b34cf-161">Similar to the [NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager) class, the [MessagingFactory](/dotnet/api/microsoft.servicebus.messaging.messagingfactory) instance is created from the base address of the service namespace and the token provider.</span></span>

```csharp
 BrokeredMessage bm = new BrokeredMessage(salesData);
 bm.Label = "SalesReport";
 bm.Properties["StoreName"] = "Redmond";
 bm.Properties["MachineID"] = "POS_1";
```

<span data-ttu-id="b34cf-162">Meddelanden som skickas till och tas emot från Service Bus-köer är instanser av den [BrokeredMessage](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage) klass.</span><span class="sxs-lookup"><span data-stu-id="b34cf-162">Messages sent to, and received from Service Bus queues are instances of the [BrokeredMessage](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage) class.</span></span> <span data-ttu-id="b34cf-163">Den här klassen består av en uppsättning standardegenskaper (t.ex [etikett](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Label) och [TimeToLive](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_TimeToLive)), en ordlista som används för att lagra egenskaper för programmet och en brödtext med godtyckliga programdata.</span><span class="sxs-lookup"><span data-stu-id="b34cf-163">This class consists of a set of standard properties (such as [Label](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Label) and [TimeToLive](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_TimeToLive)), a dictionary that is used to hold application properties, and a body of arbitrary application data.</span></span> <span data-ttu-id="b34cf-164">Ett program kan konfigurera meddelandets brödtext genom att passera i någon typ av serialiserbara objekt (i följande exempel skickas i en **SalesData** objekt som representerar försäljningsdata från terminalen POS), som använder den [DataContractSerializer](https://msdn.microsoft.com/library/system.runtime.serialization.datacontractserializer.aspx) att serialisera objektet.</span><span class="sxs-lookup"><span data-stu-id="b34cf-164">An application can set the body by passing in any serializable object (the following example passes in a **SalesData** object that represents the sales data from the POS terminal), which will use the [DataContractSerializer](https://msdn.microsoft.com/library/system.runtime.serialization.datacontractserializer.aspx) to serialize the object.</span></span> <span data-ttu-id="b34cf-165">Du kan också en [dataströmmen](https://msdn.microsoft.com/library/system.io.stream.aspx) objekt kan anges.</span><span class="sxs-lookup"><span data-stu-id="b34cf-165">Alternatively, a [Stream](https://msdn.microsoft.com/library/system.io.stream.aspx) object can be provided.</span></span>

<span data-ttu-id="b34cf-166">Det enklaste sättet att skicka meddelanden till en viss kö, i vårt fall den **DataCollectionQueue**, är att använda [CreateMessageSender](/dotnet/api/microsoft.servicebus.messaging.messagingfactory#Microsoft_ServiceBus_Messaging_MessagingFactory_CreateMessageSender_System_String_) att skapa en [MessageSender](/dotnet/api/microsoft.servicebus.messaging.messagesender) objektet direkt från den [MessagingFactory](/dotnet/api/microsoft.servicebus.messaging.messagingfactory) instans.</span><span class="sxs-lookup"><span data-stu-id="b34cf-166">The easiest way to send messages to a given queue, in our case the **DataCollectionQueue**, is to use [CreateMessageSender](/dotnet/api/microsoft.servicebus.messaging.messagingfactory#Microsoft_ServiceBus_Messaging_MessagingFactory_CreateMessageSender_System_String_) to create a [MessageSender](/dotnet/api/microsoft.servicebus.messaging.messagesender) object directly from the [MessagingFactory](/dotnet/api/microsoft.servicebus.messaging.messagingfactory) instance.</span></span>

```csharp
MessageSender sender = factory.CreateMessageSender("DataCollectionQueue");
sender.Send(bm);
```

### <a name="receiving-messages-from-the-queue"></a><span data-ttu-id="b34cf-167">Ta emot meddelanden från kön</span><span class="sxs-lookup"><span data-stu-id="b34cf-167">Receiving messages from the queue</span></span>
<span data-ttu-id="b34cf-168">Om du vill ta emot meddelanden från kön, kan du använda en [MessageReceiver](/dotnet/api/microsoft.servicebus.messaging.messagereceiver) objekt som du skapar direkt från den [MessagingFactory](/dotnet/api/microsoft.servicebus.messaging.messagingfactory) med [CreateMessageReceiver](/dotnet/api/microsoft.servicebus.messaging.messagingfactory#Microsoft_ServiceBus_Messaging_MessagingFactory_CreateMessageReceiver_System_String_).</span><span class="sxs-lookup"><span data-stu-id="b34cf-168">To receive messages from the queue, you can use a [MessageReceiver](/dotnet/api/microsoft.servicebus.messaging.messagereceiver) object which you create directly from the [MessagingFactory](/dotnet/api/microsoft.servicebus.messaging.messagingfactory) using [CreateMessageReceiver](/dotnet/api/microsoft.servicebus.messaging.messagingfactory#Microsoft_ServiceBus_Messaging_MessagingFactory_CreateMessageReceiver_System_String_).</span></span> <span data-ttu-id="b34cf-169">Meddelandet mottagare kan arbeta i två olika lägen: **ReceiveAndDelete** och **PeekLock**.</span><span class="sxs-lookup"><span data-stu-id="b34cf-169">Message receivers can work in two different modes: **ReceiveAndDelete** and **PeekLock**.</span></span> <span data-ttu-id="b34cf-170">Den [ReceiveMode](/dotnet/api/microsoft.servicebus.messaging.receivemode) anges när meddelandet mottagaren har skapats som en parameter för den [CreateMessageReceiver](/dotnet/api/microsoft.servicebus.messaging.messagingfactory?redirectedfrom=MSDN#Microsoft_ServiceBus_Messaging_MessagingFactory_CreateMessageReceiver_System_String_Microsoft_ServiceBus_Messaging_ReceiveMode_) anropa.</span><span class="sxs-lookup"><span data-stu-id="b34cf-170">The [ReceiveMode](/dotnet/api/microsoft.servicebus.messaging.receivemode) is set when the message receiver is created, as a parameter to the [CreateMessageReceiver](/dotnet/api/microsoft.servicebus.messaging.messagingfactory?redirectedfrom=MSDN#Microsoft_ServiceBus_Messaging_MessagingFactory_CreateMessageReceiver_System_String_Microsoft_ServiceBus_Messaging_ReceiveMode_) call.</span></span>

<span data-ttu-id="b34cf-171">När du använder den **ReceiveAndDelete** läge Receive-aktiviteten är en engångsåtgärd, det vill säga när Service Bus tar emot begäran, den markerar meddelandet som Förbrukat och skickar tillbaka det till programmet.</span><span class="sxs-lookup"><span data-stu-id="b34cf-171">When using the **ReceiveAndDelete** mode, the receive is a single-shot operation; that is, when Service Bus receives the request, it marks the message as being consumed and returns it to the application.</span></span> <span data-ttu-id="b34cf-172">**ReceiveAndDelete** läge är den enklaste modellen och fungerar bäst för scenarier där programmet kan tolerera icke-bearbetning av ett meddelande om ett fel skulle inträffa.</span><span class="sxs-lookup"><span data-stu-id="b34cf-172">**ReceiveAndDelete** mode is the simplest model and works best for scenarios in which the application can tolerate not processing a message if a failure were to occur.</span></span> <span data-ttu-id="b34cf-173">För att förstå detta kan du föreställa dig ett scenario där konsumenten utfärdar en receive-begäran och sedan kraschar innan den kan bearbeta denna begäran.</span><span class="sxs-lookup"><span data-stu-id="b34cf-173">To understand this, consider a scenario in which the consumer issues the receive request and then crashes before processing it.</span></span> <span data-ttu-id="b34cf-174">Eftersom Service Bus markerat meddelandet som Förbrukat när programmet startas om och börjar förbruka meddelanden igen, att ha missat meddelandet som förbrukades innan kraschen.</span><span class="sxs-lookup"><span data-stu-id="b34cf-174">Since Service Bus marked the message as being consumed, when the application restarts and starts consuming messages again, it will have missed the message that was consumed before the crash.</span></span>

<span data-ttu-id="b34cf-175">I **PeekLock** läge inleveransen en åtgärd i två steg, vilket gör det möjligt att stödprogram som inte tolererar att ett meddelande saknas.</span><span class="sxs-lookup"><span data-stu-id="b34cf-175">In **PeekLock** mode, the receive becomes a two-stage operation, which makes it possible to support applications that cannot tolerate missing messages.</span></span> <span data-ttu-id="b34cf-176">När Service Bus tar emot begäran, den söker efter nästa meddelande som ska förbrukas, låser det för att förhindra andra användare tar emot det och skickar sedan tillbaka det till programmet.</span><span class="sxs-lookup"><span data-stu-id="b34cf-176">When Service Bus receives the request, it finds the next message to be consumed, locks it to prevent other consumers receiving it, and then returns it to the application.</span></span> <span data-ttu-id="b34cf-177">När programmet har avslutat bearbetningen av meddelandet (eller lagrar det på ett tillförlitligt sätt för framtida bearbetning), slutför programmet det andra steget i processen genom att anropa [Slutför](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Complete) för det mottagna meddelandet.</span><span class="sxs-lookup"><span data-stu-id="b34cf-177">After the application finishes processing the message (or stores it reliably for future processing), it completes the second stage of the receive process by calling [Complete](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Complete) on the received message.</span></span> <span data-ttu-id="b34cf-178">När Service Bus ser den [Slutför](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Complete) anrop, markerar den meddelandet som Förbrukat.</span><span class="sxs-lookup"><span data-stu-id="b34cf-178">When Service Bus sees the [Complete](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Complete) call, it marks the message as being consumed.</span></span>

<span data-ttu-id="b34cf-179">Två resultat är möjliga.</span><span class="sxs-lookup"><span data-stu-id="b34cf-179">Two other outcomes are possible.</span></span> <span data-ttu-id="b34cf-180">Först om programmet inte kan bearbeta meddelandet av någon anledning, kan det anropa [Avbryt](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Abandon) för det mottagna meddelandet (i stället för [Slutför](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Complete)).</span><span class="sxs-lookup"><span data-stu-id="b34cf-180">First, if the application is unable to process the message for some reason, it can call [Abandon](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Abandon) on the received message (instead of [Complete](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Complete)).</span></span> <span data-ttu-id="b34cf-181">Detta gör att Service Bus att låsa upp meddelandet och gör det tillgängligt att tas emot igen, antingen genom samma konsumenten eller av en annan Slutför konsument.</span><span class="sxs-lookup"><span data-stu-id="b34cf-181">This causes Service Bus to unlock the message and make it available to be received again, either by the same consumer or by another completing consumer.</span></span> <span data-ttu-id="b34cf-182">Det finns en tidsgräns som är kopplade till låset och om programmet går inte att bearbeta meddelandet innan tidsgränsen för låsning går ut (till exempel om programmet kraschar), kommer Service Bus att låsa upp meddelandet och gör det tillgängligt och kan tas emot igen (andra: i praktiken utför en [Avbryt](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Abandon) åtgärden som standard).</span><span class="sxs-lookup"><span data-stu-id="b34cf-182">Second, there is a time-out associated with the lock and if the application cannot process the message before the lock time-out expires (for example, if the application crashes), then Service Bus will unlock the message and make it available to be received again (essentially performing an [Abandon](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Abandon) operation by default).</span></span>

<span data-ttu-id="b34cf-183">Observera att om programmet kraschar efter den bearbetar meddelandet men innan det [Slutför](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Complete) begäran gjordes, meddelandet att levereras till programmet när den startas om.</span><span class="sxs-lookup"><span data-stu-id="b34cf-183">Note that if the application crashes after it processes the message but before the [Complete](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Complete) request was issued, the message will be redelivered to the application when it restarts.</span></span> <span data-ttu-id="b34cf-184">Detta kallas ofta * minst en gång * bearbetning.</span><span class="sxs-lookup"><span data-stu-id="b34cf-184">This is often termed *At Least Once * processing.</span></span> <span data-ttu-id="b34cf-185">Detta innebär att varje meddelande bearbetas minst en gång men i vissa situationer kan samma meddelande levereras.</span><span class="sxs-lookup"><span data-stu-id="b34cf-185">This means that each message will be processed at least once but in certain situations the same message may be redelivered.</span></span> <span data-ttu-id="b34cf-186">Om scenariot inte tolererar duplicerad bearbetning, krävs ytterligare logik i programmet för att identifiera dubbletter.</span><span class="sxs-lookup"><span data-stu-id="b34cf-186">If the scenario cannot tolerate duplicate processing, then additional logic is required in the application to detect duplicates.</span></span> <span data-ttu-id="b34cf-187">Detta kan uppnås baserat på de [MessageId](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_MessageId) för meddelandet.</span><span class="sxs-lookup"><span data-stu-id="b34cf-187">This can be achieved based on the [MessageId](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_MessageId) property of the message.</span></span> <span data-ttu-id="b34cf-188">Värdet för den här egenskapen förblir konstant under alla leveransförsök.</span><span class="sxs-lookup"><span data-stu-id="b34cf-188">The value of this property remains constant across delivery attempts.</span></span> <span data-ttu-id="b34cf-189">Detta kallas *exakt en gång* bearbetning.</span><span class="sxs-lookup"><span data-stu-id="b34cf-189">This is termed *Exactly Once* processing.</span></span>

<span data-ttu-id="b34cf-190">Koden som visas här tar emot och bearbetar ett meddelande med hjälp av den **PeekLock** läge, som är standard om inget [ReceiveMode](/dotnet/api/microsoft.servicebus.messaging.receivemode) värde anges explicit.</span><span class="sxs-lookup"><span data-stu-id="b34cf-190">The code that is shown here receives and processes a message using the **PeekLock** mode, which is the default if no [ReceiveMode](/dotnet/api/microsoft.servicebus.messaging.receivemode) value is explicitly provided.</span></span>

```csharp
MessageReceiver receiver = factory.CreateMessageReceiver("DataCollectionQueue");
BrokeredMessage receivedMessage = receiver.Receive();
try
{
    ProcessMessage(receivedMessage);
    receivedMessage.Complete();
}
catch (Exception e)
{
    receivedMessage.Abandon();
}
```

### <a name="use-the-queue-client"></a><span data-ttu-id="b34cf-191">Använd klienten för kön</span><span class="sxs-lookup"><span data-stu-id="b34cf-191">Use the queue client</span></span>
<span data-ttu-id="b34cf-192">Exemplen tidigare i det här avsnittet skapas [MessageSender](/dotnet/api/microsoft.servicebus.messaging.messagesender) och [MessageReceiver](/dotnet/api/microsoft.servicebus.messaging.messagereceiver) objekt direkt från den [MessagingFactory](/dotnet/api/microsoft.servicebus.messaging.messagingfactory) skicka och ta emot meddelanden från den kö, respektive.</span><span class="sxs-lookup"><span data-stu-id="b34cf-192">The examples earlier in this section created [MessageSender](/dotnet/api/microsoft.servicebus.messaging.messagesender) and [MessageReceiver](/dotnet/api/microsoft.servicebus.messaging.messagereceiver) objects directly from the [MessagingFactory](/dotnet/api/microsoft.servicebus.messaging.messagingfactory) to send and receive messages from the queue, respectively.</span></span> <span data-ttu-id="b34cf-193">En annan metod är att använda en [QueueClient](/dotnet/api/microsoft.servicebus.messaging.queueclient) objektet, vilket stöder både skicka och ta emot operations förutom mer avancerade funktioner, till exempel sessioner.</span><span class="sxs-lookup"><span data-stu-id="b34cf-193">An alternative approach is to use a [QueueClient](/dotnet/api/microsoft.servicebus.messaging.queueclient) object, which supports both send and receive operations in addition to more advanced features, such as sessions.</span></span>

```csharp
QueueClient queueClient = factory.CreateQueueClient("DataCollectionQueue");
queueClient.Send(bm);

BrokeredMessage message = queueClient.Receive();

try
{
    ProcessMessage(message);
    message.Complete();
}
catch (Exception e)
{
    message.Abandon();
} 
```

## <a name="next-steps"></a><span data-ttu-id="b34cf-194">Nästa steg</span><span class="sxs-lookup"><span data-stu-id="b34cf-194">Next steps</span></span>
<span data-ttu-id="b34cf-195">Nu när du har lärt dig grunderna om köer finns [skapa program som använder Service Bus-ämnen och prenumerationer](service-bus-create-topics-subscriptions.md) fortsätta den här diskussionen med Publicera/prenumerera-funktionerna i Service Bus-ämnen och prenumerationer.</span><span class="sxs-lookup"><span data-stu-id="b34cf-195">Now that you've learned the basics of queues, see [Create applications that use Service Bus topics and subscriptions](service-bus-create-topics-subscriptions.md) to continue this discussion using the publish/subscribe capabilities of Service Bus topics and subscriptions.</span></span>

